<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>初学算法：链接表题目汇总 - Morgan Freewoman</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            初学算法：链接表题目汇总
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-07-26T04:02:25.000Z" itemprop="datePublished">Jul 26 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            14 minutes read (About 2166 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>以下是leetcode中，我觉得难度适中的几道链接表题目，在这里记录下来，以供未来复习之用。</p>
<span id="more"></span>
<h3 id="EASY"><a href="#EASY" class="headerlink" title="EASY:"></a>EASY:</h3><h4 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode: 21 Merge Two Sorted Lists"></a>Leetcode: 21 Merge Two Sorted Lists</h4><p>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<ol>
<li>Iteration方法，注意循环到最后，将l1或l2剩余的部分链接到末。<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=0, next=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.next = next</span><br><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        # iteration</span><br><span class="line"></span><br><span class="line">        prehead = ListNode(-1)</span><br><span class="line">        prev = prehead</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt; l2.val:</span><br><span class="line">                prev.next = l1</span><br><span class="line">                prev = prev.next</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            else:</span><br><span class="line">                prev.next = l2</span><br><span class="line">                prev = prev.next</span><br><span class="line">                l2 = l2.next</span><br><span class="line"></span><br><span class="line">        if l1 is not None:</span><br><span class="line">            prev.next = l1</span><br><span class="line">        else:</span><br><span class="line">            prev.next = l2</span><br><span class="line"></span><br><span class="line">        return prehead.next</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-141-Linked-List-Cycle"><a href="#Leetcode-141-Linked-List-Cycle" class="headerlink" title="Leetcode: 141 Linked List Cycle"></a>Leetcode: 141 Linked List Cycle</h4><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
<ol>
<li><p>set</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        nodes_seen = set()</span><br><span class="line">        while head is not None:</span><br><span class="line">            if head in nodes_seen:</span><br><span class="line">                return True</span><br><span class="line">            nodes_seen.add(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        return False</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>two runner</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        if head is None:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        fast = head.next</span><br><span class="line">        slow = head</span><br><span class="line"></span><br><span class="line">        while fast != slow:</span><br><span class="line">            if  fast is None or fast.next is None:</span><br><span class="line">                return False</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line"></span><br><span class="line">        return True</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-160-Intersection-of-Two-Linked-Lists"><a href="#Leetcode-160-Intersection-of-Two-Linked-Lists" class="headerlink" title="Leetcode: 160 Intersection of Two Linked Lists"></a>Leetcode: 160 Intersection of Two Linked Lists</h4><p>Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.</p>
<p>For example, the following two linked lists begin to intersect at node c1:</p>
<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>
<p>Note that the linked lists must retain their original structure after the function returns.</p>
<p>Custom Judge:</p>
<p>The inputs to the judge are given as follows (your program is not given these inputs):</p>
<p>intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.<br>listA - The first linked list.<br>listB - The second linked list.<br>skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.<br>skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.<br>The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.</p>
<ol>
<li><p>Hash table</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        nodeB = set()</span><br><span class="line">        while headB is not None:</span><br><span class="line">            nodeB.add(headB)</span><br><span class="line">            headB = headB.next</span><br><span class="line"></span><br><span class="line">        while headA is not None:</span><br><span class="line">            if headA in nodeB:</span><br><span class="line">                return headA</span><br><span class="line">            headA = headA.next</span><br><span class="line"></span><br><span class="line">        return None</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Two runner<br>解析：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/solution/">https://leetcode.com/problems/intersection-of-two-linked-lists/solution/</a></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        pA = headA</span><br><span class="line">        pB = headB</span><br><span class="line"></span><br><span class="line">        while pA != pB:</span><br><span class="line">            if pA is None:</span><br><span class="line">                pA = headB</span><br><span class="line">            else:</span><br><span class="line">                pA = pA.next</span><br><span class="line"></span><br><span class="line">            if pB is None:</span><br><span class="line">                pB = headA</span><br><span class="line">            else:</span><br><span class="line">                pB = pB.next</span><br><span class="line"></span><br><span class="line">        return pA</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-206-Reverse-Linked-List"><a href="#Leetcode-206-Reverse-Linked-List" class="headerlink" title="Leetcode: 206 Reverse Linked List"></a>Leetcode: 206 Reverse Linked List</h4><p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
<ol>
<li><p>Iteration</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        left = None</span><br><span class="line">        mid = head</span><br><span class="line">        right = head.next</span><br><span class="line"></span><br><span class="line">        while right is not None:</span><br><span class="line">            mid.next = left</span><br><span class="line">            left = mid</span><br><span class="line">            mid = right</span><br><span class="line">            right = right.next</span><br><span class="line">        mid.next = left</span><br><span class="line">        return mid</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>Clean version</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def reverseList(self, head):</span><br><span class="line">    previous = None</span><br><span class="line">    current = head</span><br><span class="line">    while current is not None:</span><br><span class="line">        next_node = current.next</span><br><span class="line">        current.next = previous</span><br><span class="line">        previous = current</span><br><span class="line">        current = next_node</span><br><span class="line">    return previous</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Recursion: 注意在这里p传递了linked-list的最后一个节点，也就是新的链头</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        p =  self.reverseList(head.next)</span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = None</span><br><span class="line">        return p</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-234-Palindrome-Linked-List"><a href="#Leetcode-234-Palindrome-Linked-List" class="headerlink" title="Leetcode: 234 Palindrome Linked List (*)"></a>Leetcode: 234 Palindrome Linked List (*)</h4><p>Given the head of a singly linked list, return true if it is a palindrome.<br>Like 1 -&gt; 2 -&gt; 2 -&gt; 1</p>
<ol>
<li><p>Python 方法 = Copy into Array List and then Use Two Pointer Technique</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">    vals = []</span><br><span class="line">    current_node = head</span><br><span class="line">    while current_node is not None:</span><br><span class="line">        vals.append(current_node.val)</span><br><span class="line">        current_node = current_node.next</span><br><span class="line">    return vals == vals[::-1]</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Recursive (great animation at <a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/solution/">https://leetcode.com/problems/palindrome-linked-list/solution/</a>) (*)<br>If we iterate the nodes in reverse using recursion, and iterate forward at the same time using a variable outside the recursive function, then we can check whether or not we have a palindrome.</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line"></span><br><span class="line">    self.front_pointer = head</span><br><span class="line"></span><br><span class="line">    def recursively_check(current_node=head):</span><br><span class="line">        if current_node is not None:</span><br><span class="line">            if not recursively_check(current_node.next):</span><br><span class="line">                return False</span><br><span class="line">            if self.front_pointer.val != current_node.val:</span><br><span class="line">                return False</span><br><span class="line">            self.front_pointer = self.front_pointer.next</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    return recursively_check()</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Reverse the second half<br>The only way we can avoid using O(n) extra space is by modifying the input in-place. The above two solution are all O(n) space.</p>
</li>
</ol>
<p>The strategy we can use is to reverse the second half of the Linked List in-place (modifying the Linked List structure), and then comparing it with the first half. Afterwards, we should re-reverse the second half and put the list back together. While you don’t need to restore the list to pass the test cases, it is still good programming practice because the function could be a part of a bigger program that doesn’t want the Linked List broken.</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        if head is None:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">        # Find the end of first half and reverse second half.</span><br><span class="line">        first_half_end = self.end_of_first_half(head)</span><br><span class="line">        second_half_start = self.reverse_list(first_half_end.next)</span><br><span class="line"></span><br><span class="line">        # Check whether or not there's a palindrome.</span><br><span class="line">        result = True</span><br><span class="line">        first_position = head</span><br><span class="line">        second_position = second_half_start</span><br><span class="line">        while result and second_position is not None:</span><br><span class="line">            if first_position.val != second_position.val:</span><br><span class="line">                result = False</span><br><span class="line">            first_position = first_position.next</span><br><span class="line">            second_position = second_position.next</span><br><span class="line"></span><br><span class="line">        # Restore the list and return the result.</span><br><span class="line">        first_half_end.next = self.reverse_list(second_half_start)</span><br><span class="line">        return result    </span><br><span class="line"></span><br><span class="line">    def end_of_first_half(self, head):</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        while fast.next is not None and fast.next.next is not None:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        return slow</span><br><span class="line"></span><br><span class="line">    def reverse_list(self, head):</span><br><span class="line">        previous = None</span><br><span class="line">        current = head</span><br><span class="line">        while current is not None:</span><br><span class="line">            next_node = current.next</span><br><span class="line">            current.next = previous</span><br><span class="line">            previous = current</span><br><span class="line">            current = next_node</span><br><span class="line">        return previous</span><br></pre></td></tr></tbody></table></figure>
<p>end_of_first_half 和 reverse_list两个function值得借鉴</p>
<hr>
<h3 id="MEDIUM"><a href="#MEDIUM" class="headerlink" title="MEDIUM"></a>MEDIUM</h3><h4 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode: 19 Remove Nth Node From End of List"></a>Leetcode: 19 Remove Nth Node From End of List</h4><p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<ol>
<li><p>One Pass: 前后两个相邻n的指针</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        fast = slow = head</span><br><span class="line">        for _ in range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        if not fast:</span><br><span class="line">            return head.next</span><br><span class="line">        while fast.next:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        slow.next = slow.next.next</span><br><span class="line">        return head</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Two pass: 一个pass算LL的长度，一个pass来remove</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:</span><br><span class="line"></span><br><span class="line">        if head.next is None:</span><br><span class="line">            if n==1:</span><br><span class="line">                return None</span><br><span class="line"></span><br><span class="line">        p1 = head</span><br><span class="line">        l = 0</span><br><span class="line">        while p1:</span><br><span class="line">            l += 1</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        p2 = head</span><br><span class="line">        if l-n-1&gt;=0:</span><br><span class="line">            for i in range(l-n-1):</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            p2.next =  p2.next.next</span><br><span class="line">        else:</span><br><span class="line">            return head.next</span><br><span class="line"></span><br><span class="line">        return head</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode: 24 Swap Nodes in Pairs"></a>Leetcode: 24 Swap Nodes in Pairs</h4><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.)</p>
<ol>
<li><p>Iterative</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return head</span><br><span class="line">        prehead = ListNode(0)</span><br><span class="line">        prehead.next = head    </span><br><span class="line">        prev = prehead</span><br><span class="line"></span><br><span class="line">        while head and head.next:</span><br><span class="line">            first = head</span><br><span class="line">            second = head.next</span><br><span class="line"></span><br><span class="line">            prev.next = second</span><br><span class="line">            first.next = second.next</span><br><span class="line">            second.next = first</span><br><span class="line"></span><br><span class="line">            prev = first</span><br><span class="line">            head = first.next</span><br><span class="line"></span><br><span class="line">        return prehead.next</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Recursion<br>My solution</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return head</span><br><span class="line">        prehead = ListNode(0)</span><br><span class="line">        prehead.next = head    </span><br><span class="line">        prev = prehead</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        def swap(prev, head):</span><br><span class="line">            if head is None or head.next is None:</span><br><span class="line">                return head</span><br><span class="line"></span><br><span class="line">            first = head</span><br><span class="line">            second = head.next</span><br><span class="line"></span><br><span class="line">            prev.next = second</span><br><span class="line">            first.next = second.next</span><br><span class="line">            second.next = first</span><br><span class="line"></span><br><span class="line">            prev = first</span><br><span class="line">            head = first.next</span><br><span class="line"></span><br><span class="line">            return swap(prev, head)</span><br><span class="line"></span><br><span class="line">        swap(prehead, head)   </span><br><span class="line">        return prehead.next</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>Leetcode Solution</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        first = head</span><br><span class="line">        second = head.next</span><br><span class="line"></span><br><span class="line">        first.next = self.swapPairs(second.next)</span><br><span class="line">        second.next = first</span><br><span class="line"></span><br><span class="line">        return second</span><br></pre></td></tr></tbody></table></figure>


<h4 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode: 61 Rotate List"></a>Leetcode: 61 Rotate List</h4><p>Given the head of a linked list, rotate the list to the right by k places.</p>
<ol>
<li>Break the ring<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=0, next=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.next = next</span><br><span class="line">class Solution:</span><br><span class="line">    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:</span><br><span class="line">        if head is None or head.next is None or k==0:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        l = 1</span><br><span class="line">        tail = head</span><br><span class="line">        while tail.next:</span><br><span class="line">            l += 1</span><br><span class="line">            tail = tail.next</span><br><span class="line">        tail.next = head</span><br><span class="line"></span><br><span class="line">        p2 = head    </span><br><span class="line">        for i in range(l-k%l-1):</span><br><span class="line">            p2 = p2.next</span><br><span class="line"></span><br><span class="line">        newhead = p2.next</span><br><span class="line">        p2.next = None</span><br><span class="line"></span><br><span class="line">        return newhead</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode: 92 Reverse Linked List II (*)"></a>Leetcode: 92 Reverse Linked List II (*)</h4><p>Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.</p>
<ol>
<li>Iterative Link Reversal<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseBetween(self, head, m, n):</span><br><span class="line">        """</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span><br><span class="line"></span><br><span class="line">        # Empty list</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        # Move the two pointers until they reach the proper starting point</span><br><span class="line">        # in the list.</span><br><span class="line">        cur, prev = head, None</span><br><span class="line">        while m &gt; 1:</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line">            m, n = m - 1, n - 1</span><br><span class="line"></span><br><span class="line">        # The two pointers that will fix the final connections.</span><br><span class="line">        tail, con = cur, prev</span><br><span class="line"></span><br><span class="line">        # Iteratively reverse the nodes until n becomes 0.</span><br><span class="line">        while n:</span><br><span class="line">            third = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = third</span><br><span class="line">            n -= 1</span><br><span class="line"></span><br><span class="line">        # Adjust the final connections as explained in the algorithm</span><br><span class="line">        if con:</span><br><span class="line">            con.next = prev</span><br><span class="line">        else:</span><br><span class="line">            head = prev</span><br><span class="line">        tail.next = cur</span><br><span class="line">        return head</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode: 143 Reorder List"></a>Leetcode: 143 Reorder List</h4><p>Question: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-list/">https://leetcode.com/problems/reorder-list/</a></p>
<p>This problem is a combination of these three easy problems:</p>
<ul>
<li>Middle of the Linked List.</li>
<li>Reverse Linked List.</li>
<li>Merge Two Sorted Lists.<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: Optional[ListNode]) -&gt; None:</span><br><span class="line">        """</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        """</span><br><span class="line"></span><br><span class="line">        def start_of_2st_half(head):</span><br><span class="line">            fast = head</span><br><span class="line">            slow = head</span><br><span class="line">            while fast and fast.next:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next                </span><br><span class="line">            return slow</span><br><span class="line">        # if 1 2 3 4 5 6 then 4 is the start of 2nd half</span><br><span class="line">        # if 1 2 3 4 5 6 7 then 4 is the start of 2nd half</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        def reverse(head):</span><br><span class="line">            previous = None</span><br><span class="line">            current = head</span><br><span class="line">            while current is not None:</span><br><span class="line">                next_node = current.next</span><br><span class="line">                current.next = previous</span><br><span class="line">                previous = current</span><br><span class="line">                current = next_node</span><br><span class="line">            return previous</span><br><span class="line"></span><br><span class="line">        startOf2 = start_of_2st_half(head)</span><br><span class="line">        rev2 = reverse(startOf2)</span><br><span class="line"></span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = rev2</span><br><span class="line">        while p2.next:</span><br><span class="line">            tmp = p1.next</span><br><span class="line">            p1.next = p2</span><br><span class="line">            p1 = tmp</span><br><span class="line"></span><br><span class="line">            tmp = p2.next</span><br><span class="line">            p2.next = p1</span><br><span class="line">            p2 = tmp</span><br><span class="line"></span><br><span class="line">        return head</span><br></pre></td></tr></tbody></table></figure>
Leetcode Solution<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: Optional[ListNode]) -&gt; None:</span><br><span class="line">        """</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        """</span><br><span class="line"></span><br><span class="line">        def start_of_2st_half(head):</span><br><span class="line">            fast = head</span><br><span class="line">            slow = head</span><br><span class="line">            while fast and fast.next:</span><br><span class="line">                fast = fast.next.next</span><br><span class="line">                slow = slow.next                </span><br><span class="line">            return slow</span><br><span class="line"></span><br><span class="line">        def reverse(head):</span><br><span class="line">            previous = None</span><br><span class="line">            current = head</span><br><span class="line">            while current is not None:</span><br><span class="line">                next_node = current.next</span><br><span class="line">                current.next = previous</span><br><span class="line">                previous = current</span><br><span class="line">                current = next_node</span><br><span class="line">            return previous</span><br><span class="line"></span><br><span class="line">        startOf2 = start_of_2st_half(head)</span><br><span class="line">        rev2 = reverse(startOf2)</span><br><span class="line"></span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = rev2</span><br><span class="line">        while p2.next:</span><br><span class="line">            tmp = p1.next</span><br><span class="line">            p1.next = p2</span><br><span class="line">            p1 = tmp</span><br><span class="line"></span><br><span class="line">            tmp = p2.next</span><br><span class="line">            p2.next = p1</span><br><span class="line">            p2 = tmp</span><br><span class="line"></span><br><span class="line">        return head</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Algorithm/">#Algorithm</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Leetcode/">#Leetcode</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2021/07/26/leetcode-sql/">Leetcode上的SQL题（Part 1）</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2021/05/20/RMD-generate-document/">R Markdown 模板自动生成文件</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 Morgan Y&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>




<script src="/js/script.js"></script>


    
</body>
</html>