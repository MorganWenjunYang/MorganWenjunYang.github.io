<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>初学算法：动态规划、贪心和回溯问题 - Morgan Freewoman</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            初学算法：动态规划、贪心和回溯问题
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-07-26T10:11:44.000Z" itemprop="datePublished">Jul 26 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            12 minutes read (About 1805 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>以下是leetcode中，我觉得难度适中的几道动态规划、贪心和回溯问题，在这里记录下来，以供未来复习之用。</p>
<p>首先先过一下简要定义和区别。网络上有两篇很好的讲解：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/article/yXFal5/">https://leetcode-cn.com/circle/article/yXFal5/</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022925306?utm_source=sf-similar-article">https://segmentfault.com/a/1190000022925306?utm_source=sf-similar-article</a><span id="more"></span></li>
</ul>
<h3 id="EASY"><a href="#EASY" class="headerlink" title="EASY:"></a>EASY:</h3><h4 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h4><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array.</p>
<p>Example 1:</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></tbody></table></figure>

<p>logics:</p>
<p>any subarray whose sum is positive is worth keeping. Let’s start with an empty array, and iterate through the input, adding numbers to our array as we go along. Whenever the sum of the array is negative, we know the entire array is not worth keeping, so we’ll reset it back to an empty array.</p>
<ol>
<li>Dynamic Programming<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSubArray(self, nums):</span><br><span class="line">        """</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        l=len(nums)</span><br><span class="line">        max_cur_end=nums[0]</span><br><span class="line">        max_tot=max_cur_end</span><br><span class="line">        for i in range(1,l):</span><br><span class="line">            max_cur_end=max(max_cur_end+nums[i],nums[i])</span><br><span class="line">            max_tot=max(max_cur_end,max_tot)</span><br><span class="line">        return max_tot</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h4><p>You are climbing a staircase. It takes n steps to reach the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<ol>
<li><p>DP with memorization</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def climbStairs(self, n):</span><br><span class="line">        """</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        if n == 1:</span><br><span class="line">            return 1</span><br><span class="line">        dp = [0] * (n+1)</span><br><span class="line">        dp[0] = 1</span><br><span class="line">        dp[1] = 1</span><br><span class="line">        for i in range(2,n+1):</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2]</span><br><span class="line"></span><br><span class="line">        return dp[n]</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>斐波那契</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def climbStairs(self, n):</span><br><span class="line">        """</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        if n == 1:</span><br><span class="line">            return 1</span><br><span class="line">        elif n == 2:</span><br><span class="line">            return 2</span><br><span class="line"></span><br><span class="line">        first = 1</span><br><span class="line">        second = 2</span><br><span class="line"></span><br><span class="line">        for i in range(3,n+1):</span><br><span class="line">            third = first + second</span><br><span class="line">            first, second = second, third</span><br><span class="line"></span><br><span class="line">        return second</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h4><p>Given the root of a binary tree, invert the tree, and return its root.</p>
<ol>
<li>Recursion<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode(object):</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution(object):</span><br><span class="line">    def invertTree(self, root):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span><br><span class="line"></span><br><span class="line">        if not root:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        root.left = right</span><br><span class="line">        root.right = left</span><br><span class="line"></span><br><span class="line">        return root</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<hr>
<h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><h4 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h4><p>You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:</p>
<p>Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1. Return the maximum number of points you can earn by applying the above operation some number of times.</p>
<ol>
<li>Optimized Dynamic Programming<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def deleteAndEarn(self, nums):</span><br><span class="line">        count = collections.Counter(nums)</span><br><span class="line">        prev = None</span><br><span class="line">        avoid = using = 0</span><br><span class="line">        for k in sorted(count):</span><br><span class="line">            if k - 1 != prev:</span><br><span class="line">                avoid, using = max(avoid, using), k * count[k] + max(avoid, using)</span><br><span class="line">            else:</span><br><span class="line">                avoid, using = max(avoid, using), k * count[k] + avoid</span><br><span class="line">            prev = k</span><br><span class="line">        return max(avoid, using)</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="198-House-Robber-similar-to-Q740"><a href="#198-House-Robber-similar-to-Q740" class="headerlink" title="198. House Robber (similar to Q740)"></a>198. House Robber (similar to Q740)</h4><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>
<ol>
<li><p>Dynamic Programming</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def rob(self, nums: List[int]) -&gt; int:</span><br><span class="line"></span><br><span class="line">        # Special handling for empty case.</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        maxRobbedAmount = [None for _ in range(len(nums) + 1)]</span><br><span class="line">        N = len(nums)</span><br><span class="line"></span><br><span class="line">        # Base case initialization.</span><br><span class="line">        maxRobbedAmount[N], maxRobbedAmount[N - 1] = 0, nums[N - 1]</span><br><span class="line"></span><br><span class="line">        # DP table calculations.</span><br><span class="line">        for i in range(N - 2, -1, -1):</span><br><span class="line"></span><br><span class="line">            # Same as recursive solution.</span><br><span class="line">            maxRobbedAmount[i] = max(maxRobbedAmount[i + 1], maxRobbedAmount[i + 2] + nums[i])</span><br><span class="line"></span><br><span class="line">        return maxRobbedAmount[0]    </span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Optimized Dynamice Programming</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def rob(self, nums: List[int]) -&gt; int:</span><br><span class="line"></span><br><span class="line">        # Special handling for empty case.</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        N = len(nums)</span><br><span class="line"></span><br><span class="line">        rob_next_plus_one = 0</span><br><span class="line">        rob_next = nums[N - 1]</span><br><span class="line"></span><br><span class="line">        # DP table calculations.</span><br><span class="line">        for i in range(N - 2, -1, -1):</span><br><span class="line"></span><br><span class="line">            # Same as recursive solution.</span><br><span class="line">            current = max(rob_next, rob_next_plus_one + nums[i])</span><br><span class="line"></span><br><span class="line">            # Update the variables</span><br><span class="line">            rob_next_plus_one = rob_next</span><br><span class="line">            rob_next = current</span><br><span class="line"></span><br><span class="line">        return rob_next</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h4><p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p>
<p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p>
<p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>
<ol>
<li>Backtracking: can be unfolded as DFS<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line"></span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        def backtrack(remain, comb, start):</span><br><span class="line">            if remain == 0:</span><br><span class="line">                # make a deep copy of the current combination</span><br><span class="line">                results.append(list(comb))</span><br><span class="line">                return</span><br><span class="line">            elif remain &lt; 0:</span><br><span class="line">                # exceed the scope, stop exploration.</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            for i in range(start, len(candidates)):</span><br><span class="line">                # add the number into the combination</span><br><span class="line">                comb.append(candidates[i])</span><br><span class="line">                # give the current number another chance, rather than moving on</span><br><span class="line">                backtrack(remain - candidates[i], comb, i)</span><br><span class="line">                # backtrack, remove the number from the combination</span><br><span class="line">                comb.pop()</span><br><span class="line"></span><br><span class="line">        backtrack(target, [], 0)</span><br><span class="line"></span><br><span class="line">        return results</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a>343. Integer Break</h4><p>Given an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers.</p>
<p>Return the maximum product you can get.</p>
<ol>
<li>Dynamic Programming<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Integer Break</span><br><span class="line">DP</span><br><span class="line">class Solution:</span><br><span class="line">    def integerBreak(self, n: int) -&gt; int:</span><br><span class="line">        # n=2 2=1+1 1*1=1</span><br><span class="line">        # n=3 3=2+1 2*1=2</span><br><span class="line">        # n=4 4=2+2 2*2=4</span><br><span class="line">        # n=5 5=3*2 2*3=6</span><br><span class="line">        # n=6 6=3+3 3*3=9</span><br><span class="line">        # n=7 7=2+2+3/4+3 2*2*3=4*3=12</span><br><span class="line">        # n=8 8=3+3+2 3*3*2=18</span><br><span class="line">        # n=9 9=3+3+3 3*3*3=27</span><br><span class="line">        # n=10 10=3+3+2+2 3*3*4=36</span><br><span class="line">        # n=11 11=3+3+3+2/3+3+3+2 54</span><br><span class="line"></span><br><span class="line">        if n==2: return 1</span><br><span class="line">        if n==3: return 2</span><br><span class="line">        if n==4: return 4</span><br><span class="line">        if n==5: return 6</span><br><span class="line">        if n==6: return 9</span><br><span class="line"></span><br><span class="line">        cand=[0]*(n+1)</span><br><span class="line">        cand[2]=1</span><br><span class="line">        cand[3]=2</span><br><span class="line">        cand[4]=4</span><br><span class="line">        cand[5]=6</span><br><span class="line">        cand[6]=9</span><br><span class="line"></span><br><span class="line">        for i in range(7,n+1):</span><br><span class="line">            cand[i]=max(3*cand[i-3],2*cand[i-2])</span><br><span class="line"></span><br><span class="line">        return cand[n]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h4><p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</p>
<p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<h4 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h4><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p>picture: see <a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a> or as summarized below</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letters = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl",</span><br><span class="line">           "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Backtracking<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits: str) -&gt; List[str]:</span><br><span class="line">        if len(digits) == 0:</span><br><span class="line">            return []</span><br><span class="line"></span><br><span class="line">        out = []</span><br><span class="line"></span><br><span class="line">        # Map all the digits to their corresponding letters</span><br><span class="line">        letters = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl",</span><br><span class="line">                   "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}</span><br><span class="line"></span><br><span class="line">        def BT(index, path):</span><br><span class="line">            if len(path) == len(digits):</span><br><span class="line">                out.append(''.join(path))</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            # Get the letters that the current digit maps to, and loop through them</span><br><span class="line">            possible_letters = letters[digits[index]]</span><br><span class="line">            for letter in possible_letters:</span><br><span class="line">                # Add the letter to our current path</span><br><span class="line">                path.append(letter)</span><br><span class="line">                # Move on to the next digit</span><br><span class="line">                BT(index + 1, path)</span><br><span class="line">                # Backtrack by removing the letter before moving onto the next</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        # Initiate backtracking with an empty path and starting index of 0</span><br><span class="line"></span><br><span class="line">        BT(0, [])</span><br><span class="line">        return out</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="91-Decode-Ways-similar-to-climbing-stairs"><a href="#91-Decode-Ways-similar-to-climbing-stairs" class="headerlink" title="91. Decode Ways (similar to climbing stairs)"></a>91. Decode Ways (similar to climbing stairs)</h4><p>A message containing letters from A-Z can be encoded into numbers using the following mapping:</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">'A' -&gt; "1"</span><br><span class="line">'B' -&gt; "2"</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; "26"</span><br></pre></td></tr></tbody></table></figure>

<p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into:</p>
<ul>
<li>“AAJF” with the grouping (1 1 10 6)</li>
<li>“KJF” with the grouping (11 10 6)</li>
</ul>
<p>Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”. Given a string s containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer.</p>
<ol>
<li>Dynamic Programming<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDecodings(self, s: str) -&gt; int:</span><br><span class="line">        # Array to store the subproblem results</span><br><span class="line">        dp = [0 for _ in range(len(s) + 1)]</span><br><span class="line"></span><br><span class="line">        dp[0] = 1</span><br><span class="line">        # Ways to decode a string of size 1 is 1. Unless the string is '0'.</span><br><span class="line">        # '0' doesn't have a single digit decode.</span><br><span class="line">        dp[1] = 0 if s[0] == '0' else 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for i in range(2, len(dp)):</span><br><span class="line"></span><br><span class="line">            # Check if successful single digit decode is possible.</span><br><span class="line">            if s[i - 1] != '0':</span><br><span class="line">                dp[i] = dp[i - 1]</span><br><span class="line"></span><br><span class="line">            # Check if successful two digit decode is possible.</span><br><span class="line">            two_digit = int(s[i - 2 : i])</span><br><span class="line">            if two_digit &gt;= 10 and two_digit &lt;= 26:</span><br><span class="line">                dp[i] += dp[i - 2]</span><br><span class="line"></span><br><span class="line">        return dp[len(s)]</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="46-Permutation"><a href="#46-Permutation" class="headerlink" title="46. Permutation"></a>46. Permutation</h4><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
<p>Example 1:</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Backtracking: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/solution/">https://leetcode.com/problems/permutations/solution/</a><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permute(self, nums):</span><br><span class="line">        """</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span><br><span class="line">        def backtrack(first = 0):</span><br><span class="line">            # if all integers are used up</span><br><span class="line">            if first == n:  </span><br><span class="line">                output.append(nums[:])</span><br><span class="line">            for i in range(first, n):</span><br><span class="line">                # place i-th integer first</span><br><span class="line">                # in the current permutation</span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line">                # use next integers to complete the permutations</span><br><span class="line">                backtrack(first + 1)</span><br><span class="line">                # backtrack</span><br><span class="line">                nums[first], nums[i] = nums[i], nums[first]</span><br><span class="line"></span><br><span class="line">        n = len(nums)</span><br><span class="line">        output = []</span><br><span class="line">        backtrack()</span><br><span class="line">        return output</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="718-Maximum-Length-of-Repeated-Subarray"><a href="#718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="718. Maximum Length of Repeated Subarray"></a>718. Maximum Length of Repeated Subarray</h4><p>Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.</p>
<ul>
<li>Example 1:<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The repeated subarray with maximum length is [3,2,1].</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ol>
<li>Dynamic Programming<br>Since a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know dp[i][j] = dp[i+1][j+1] + 1. Also, the answer is max(dp[i][j]) over all i, j.</li>
</ol>
<p>We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in dp for any larger i, j.</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def findLength(self, A, B):</span><br><span class="line">        memo = [[0] * (len(B) + 1) for _ in range(len(A) + 1)]</span><br><span class="line">        for i in range(len(A) - 1, -1, -1):</span><br><span class="line">            for j in range(len(B) - 1, -1, -1):</span><br><span class="line">                if A[i] == B[j]:</span><br><span class="line">                    memo[i][j] = memo[i + 1][j + 1] + 1</span><br><span class="line">        return max(max(row) for row in memo)</span><br></pre></td></tr></tbody></table></figure>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Algorithm/">#Algorithm</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Leetcode/">#Leetcode</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2021/08/06/flask-docker/">用Docker部署Flask到阿里云</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2021/07/26/Music-general/">音乐随感</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 Morgan Y&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>




<script src="/js/script.js"></script>


    
</body>
</html>