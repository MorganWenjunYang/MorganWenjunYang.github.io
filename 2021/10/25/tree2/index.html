<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>初学算法：树II (DFS、BFS、二分查找树) - Morgan Freewoman</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            初学算法：树II (DFS、BFS、二分查找树)
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-10-25T11:18:57.000Z" itemprop="datePublished">Oct 25 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            18 minutes read (About 2658 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>今天，我们大家又欢聚在一起是因为研究我最喜欢的‘树’，我要敬我的好题目，感谢她，for nothing。我也发自内心地祝愿她，从此以后被我征服。</p>
<span id="more"></span>


<h3 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h3><h4 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h4><p>You are given two binary trees root1 and root2.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return the merged tree.</p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="p617"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">Output: [3,4,5,5,4,null,7]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursion(DFS)<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line"></span><br><span class="line">        if root1 is None:</span><br><span class="line">            return root2</span><br><span class="line">        if root2 is None:</span><br><span class="line">            return root1</span><br><span class="line"></span><br><span class="line">        root1.val += root2.val</span><br><span class="line">        root1.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">        root1.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line"></span><br><span class="line">        return root1S</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="671-Second-Minimum-Node-in-a-Binary-Tree"><a href="#671-Second-Minimum-Node-in-a-Binary-Tree" class="headerlink" title="671. Second Minimum Node in a Binary Tree"></a>671. Second Minimum Node in a Binary Tree</h4><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.</p>
<p>Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree.</p>
<p>If no such second minimum value exists, output -1 instead.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg" alt="p671"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,2,5,null,null,5,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursion(DFS)<br>Let min1 = root.val. When traversing the tree at some node, node, if node.val &gt; min1, we know all values in the subtree at node are at least node.val, so there cannot be a better candidate for the second minimum in this subtree. Thus, we do not need to search this subtree. Also, as we only care about the second minimum ans, we do not need to record any values that are larger than our current candidate for the second minimum, so we can skip maintaining a Set of values(uniques) entirely.</li>
</ol>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def findSecondMinimumValue(self, root):</span><br><span class="line">    self.ans = float('inf')</span><br><span class="line">    min1 = root.val</span><br><span class="line"></span><br><span class="line">    def dfs(node):</span><br><span class="line">        if node:</span><br><span class="line">            if min1 &lt; node.val &lt; self.ans:</span><br><span class="line">                self.ans = node.val</span><br><span class="line">            elif node.val == min1:</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line"></span><br><span class="line">    dfs(root)</span><br><span class="line">    return self.ans if self.ans &lt; float('inf') else -1</span><br></pre></td></tr></tbody></table></figure>


<h4 id="783-Minimum-Distance-Between-BST-Nodes"><a href="#783-Minimum-Distance-Between-BST-Nodes" class="headerlink" title="783. Minimum Distance Between BST Nodes"></a>783. Minimum Distance Between BST Nodes</h4><p>Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="p783"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,6,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Write to array</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minDiffInBST(self, root):</span><br><span class="line">        vals = []</span><br><span class="line">        def dfs(node):</span><br><span class="line">            if node:</span><br><span class="line">                vals.append(node.val)</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        vals.sort()</span><br><span class="line">        return min(vals[i+1] - vals[i]</span><br><span class="line">                   for i in xrange(len(vals) - 1))</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>In-order traversal(DFS)<br>In a binary search tree, an in-order traversal outputs the values of the tree in order. By remembering the previous value in this order, we could iterate over each possible difference, keeping the smallest one.</p>
</li>
</ol>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minDiffInBST(self, root):</span><br><span class="line">        def dfs(node):</span><br><span class="line">            if node:</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                self.ans = min(self.ans, node.val - self.prev)</span><br><span class="line">                self.prev = node.val</span><br><span class="line">                dfs(node.right)</span><br><span class="line"></span><br><span class="line">        self.prev = float('-inf')</span><br><span class="line">        self.ans = float('inf')</span><br><span class="line">        dfs(root)</span><br><span class="line">        return self.ans</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a>112. Path Sum</h4><p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>
<p>A leaf is a node with no children.<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="p112"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Recursion</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasPathSum(self, root, sum):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span><br><span class="line">        if not root:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        sum -= root.val</span><br><span class="line">        if not root.left and not root.right:  # if reach a leaf</span><br><span class="line">            return sum == 0</span><br><span class="line">        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iterations(DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasPathSum(self, root, sum):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span><br><span class="line">        if not root:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        de = [(root, sum - root.val), ]</span><br><span class="line">        while de:</span><br><span class="line">            node, curr_sum = de.pop()</span><br><span class="line">            if not node.left and not node.right and curr_sum == 0:  </span><br><span class="line">                return True</span><br><span class="line">            if node.right:</span><br><span class="line">                de.append((node.right, curr_sum - node.right.val))</span><br><span class="line">            if node.left:</span><br><span class="line">                de.append((node.left, curr_sum - node.left.val))</span><br><span class="line">        return False</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h4><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="p111"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Recursion</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return an integer    </span><br><span class="line">    def minDepth(self, root):</span><br><span class="line">        if root == None:</span><br><span class="line">            return 0</span><br><span class="line">        if root.left==None or root.right==None:</span><br><span class="line">            return self.minDepth(root.left)+self.minDepth(root.right)+1</span><br><span class="line">        return min(self.minDepth(root.right),self.minDepth(root.left))+1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iteration(DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDepth(self, root):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            stack, min_depth = [(1, root),], float('inf')</span><br><span class="line"></span><br><span class="line">        while stack:</span><br><span class="line">            depth, root = stack.pop()</span><br><span class="line">            children = [root.left, root.right]</span><br><span class="line">            if not any(children):</span><br><span class="line">                min_depth = min(depth, min_depth)</span><br><span class="line">            for c in children:</span><br><span class="line">                if c:</span><br><span class="line">                    stack.append((depth + 1, c))</span><br><span class="line"></span><br><span class="line">        return min_depth</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iteration(BFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">class Solution:</span><br><span class="line">    def minDepth(self, root):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            node_deque = deque([(1, root),])</span><br><span class="line"></span><br><span class="line">        while node_deque:</span><br><span class="line">            depth, root = node_deque.popleft()</span><br><span class="line">            children = [root.left, root.right]</span><br><span class="line">            if not any(children):</span><br><span class="line">                return depth</span><br><span class="line">            for c in children:</span><br><span class="line">                if c:</span><br><span class="line">                    node_deque.append((depth + 1, c))</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="104-Maximum-Depth-of-Ninary-Tree"><a href="#104-Maximum-Depth-of-Ninary-Tree" class="headerlink" title="104. Maximum Depth of Ninary Tree"></a>104. Maximum Depth of Ninary Tree</h4><p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="p104"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 3</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>My recursive:</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root: Optional[TreeNode]) -&gt; int:</span><br><span class="line"></span><br><span class="line">        maxi = 0</span><br><span class="line"></span><br><span class="line">        def dep(root, cur):</span><br><span class="line">            nonlocal maxi</span><br><span class="line"></span><br><span class="line">            if root is None:</span><br><span class="line">                maxi = max(maxi, cur)</span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line">                dep(root.left, cur+1)</span><br><span class="line">                dep(root.right, cur+1)</span><br><span class="line"></span><br><span class="line">        dep(root, 0)</span><br><span class="line">        return maxi</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Recursion(DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        if root is None:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            left_height = self.maxDepth(root.left)</span><br><span class="line">            right_height = self.maxDepth(root.right)</span><br><span class="line">            return max(left_height, right_height) + 1</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iteration(Stack DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span><br><span class="line">        stack = []</span><br><span class="line">        if root is not None:</span><br><span class="line">            stack.append((1, root))</span><br><span class="line"></span><br><span class="line">        depth = 0</span><br><span class="line">        while stack != []:</span><br><span class="line">            current_depth, root = stack.pop()</span><br><span class="line">            if root is not None:</span><br><span class="line">                depth = max(depth, current_depth)</span><br><span class="line">                stack.append((current_depth + 1, root.left))</span><br><span class="line">                stack.append((current_depth + 1, root.right))</span><br><span class="line"></span><br><span class="line">        return depth</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<hr>
<h3 id="MEDIUM"><a href="#MEDIUM" class="headerlink" title="MEDIUM"></a>MEDIUM</h3><h4 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h4><p>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.</p>
<p>Return the number of good nodes in the binary tree.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" alt="p1448"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,3,null,1,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Nodes in blue are good.</span><br><span class="line">Root Node (3) is always a good node.</span><br><span class="line">Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.</span><br><span class="line">Node 5 -&gt; (3,4,5) is the maximum value in the path</span><br><span class="line">Node 3 -&gt; (3,1,3) is the maximum value in the path.</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Recursion (DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def goodNodes(self, root: TreeNode) -&gt; int:</span><br><span class="line"></span><br><span class="line">        def dfs(node, max_so_far):</span><br><span class="line">            nonlocal num_good_nodes</span><br><span class="line">            if max_so_far &lt;= node.val:</span><br><span class="line">                num_good_nodes += 1</span><br><span class="line">            if node.right:</span><br><span class="line">                dfs(node.right, max(node.val, max_so_far))</span><br><span class="line">            if node.left:</span><br><span class="line">                dfs(node.left, max(node.val, max_so_far))</span><br><span class="line"></span><br><span class="line">        num_good_nodes = 0</span><br><span class="line">        dfs(root, float("-inf"))</span><br><span class="line">        return num_good_nodes</span><br></pre></td></tr></tbody></table></figure>
<p>把之前遇到的最大值传入下一层。</p>
</li>
<li><p>Iterative (DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def goodNodes(self, root: TreeNode) -&gt; int:</span><br><span class="line">        stack = [(root, float("-inf"))]</span><br><span class="line">        num_good_nodes = 0</span><br><span class="line">        while stack:</span><br><span class="line">            node, max_so_far = stack.pop()</span><br><span class="line">            if max_so_far &lt;= node.val:</span><br><span class="line">                num_good_nodes += 1</span><br><span class="line">            if node.left:</span><br><span class="line">                stack.append((node.left, max(node.val, max_so_far)))</span><br><span class="line">            if node.right:</span><br><span class="line">                stack.append((node.right, max(node.val, max_so_far)))</span><br><span class="line"></span><br><span class="line">        return num_good_nodes</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iterative (BFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def goodNodes(self, root: TreeNode) -&gt; int:</span><br><span class="line">        num_good_nodes = 0</span><br><span class="line"></span><br><span class="line">        # Use collections.deque for efficient popping</span><br><span class="line">        queue = deque([(root, float("-inf"))])</span><br><span class="line">        while queue:</span><br><span class="line">            node, max_so_far = queue.popleft()</span><br><span class="line">            if max_so_far &lt;= node.val:</span><br><span class="line">                num_good_nodes += 1</span><br><span class="line">            if node.right:</span><br><span class="line">                queue.append((node.right, max(node.val, max_so_far)))</span><br><span class="line">            if node.left:</span><br><span class="line">                queue.append((node.left, max(node.val, max_so_far)))</span><br><span class="line"></span><br><span class="line">        return num_good_nodes</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h4><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="p236"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>My Recursive</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span><br><span class="line">        # Value of current node or parent node.</span><br><span class="line"></span><br><span class="line">        ans = None</span><br><span class="line"></span><br><span class="line">        def helper(root):</span><br><span class="line"></span><br><span class="line">            nonlocal ans</span><br><span class="line"></span><br><span class="line">            if not root:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">            l = helper(root.left)</span><br><span class="line">            r = helper(root.right)</span><br><span class="line"></span><br><span class="line">            s = root.val == p.val or root.val == q.val</span><br><span class="line"></span><br><span class="line">            if (l and r) or (l and s) or (r and s):</span><br><span class="line">                ans = root</span><br><span class="line"></span><br><span class="line">            return (s or l or r)</span><br><span class="line"></span><br><span class="line">        helper(root)</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iterative using parent pointers</p>
</li>
</ol>
<ul>
<li>Start from the root node and traverse the tree.</li>
<li>Until we find p and q both, keep storing the parent pointers in a dictionary.</li>
<li>Once we have found both p and q, we get all the ancestors for p using the parent dictionary and add to a set called ancestors.</li>
<li>Similarly, we traverse through ancestors for node q. If the ancestor is present in the ancestors set for p, this means this is the first ancestor common between p and q (while traversing upwards) and hence this is the LCA node.<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span><br><span class="line"></span><br><span class="line">        # Stack for tree traversal</span><br><span class="line">        stack = [root]</span><br><span class="line"></span><br><span class="line">        # Dictionary for parent pointers</span><br><span class="line">        parent = {root: None}</span><br><span class="line"></span><br><span class="line">        # Iterate until we find both the nodes p and q</span><br><span class="line">        while p not in parent or q not in parent:</span><br><span class="line"></span><br><span class="line">            node = stack.pop()</span><br><span class="line"></span><br><span class="line">            # While traversing the tree, keep saving the parent pointers.</span><br><span class="line">            if node.left:</span><br><span class="line">                parent[node.left] = node</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            if node.right:</span><br><span class="line">                parent[node.right] = node</span><br><span class="line">                stack.append(node.right)</span><br><span class="line"></span><br><span class="line">        # Ancestors set() for node p.</span><br><span class="line">        ancestors = set()</span><br><span class="line"></span><br><span class="line">        # Process all ancestors for node p using parent pointers.</span><br><span class="line">        while p:</span><br><span class="line">            ancestors.add(p)</span><br><span class="line">            p = parent[p]</span><br><span class="line"></span><br><span class="line">        # The first ancestor of q which appears in</span><br><span class="line">        # p's ancestor set() is their lowest common ancestor.</span><br><span class="line">        while q not in ancestors:</span><br><span class="line">            q = parent[q]</span><br><span class="line">        return q</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="863-All-Nodes-Distance-K-in-Binary-Tree"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="863. All Nodes Distance K in Binary Tree"></a>863. All Nodes Distance K in Binary Tree</h4><p>Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.</p>
<p>You can return the answer in any order.</p>
<p>Example:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="p863"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">Output: [7,4,1]</span><br><span class="line">Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Annotate Parents</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -&gt; list[int]:</span><br><span class="line">        def set_parents(root: TreeNode, parent: TreeNode) -&gt; None:</span><br><span class="line">            if root:</span><br><span class="line">                root.parent = parent</span><br><span class="line">                set_parents(root.left, root)</span><br><span class="line">                set_parents(root.right, root)</span><br><span class="line"></span><br><span class="line">        set_parents(root, None)</span><br><span class="line">        currNodes = [target]</span><br><span class="line">        visited = {target}</span><br><span class="line">        for _ in range(K):</span><br><span class="line">            nextNodes = []</span><br><span class="line">            for currNode in currNodes:</span><br><span class="line">                for node in [currNode.left, currNode.right, currNode.parent]:</span><br><span class="line">                    if node and node not in visited:</span><br><span class="line">                        visited.add(node)</span><br><span class="line">                        nextNodes.append(node)</span><br><span class="line"></span><br><span class="line">            currNodes = nextNodes</span><br><span class="line"></span><br><span class="line">        return [node.val for node in currNodes]</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Percolate Distance<br>Traverse every node with a depth first search dfs. We’ll add all nodes x to the answer such that node is the node on the path from x to target that is closest to the root.</p>
</li>
</ol>
<p>To help us, dfs(node) will return the distance from node to the target. Then, there are 4 cases:</p>
<ul>
<li><p>If node == target, then we should add nodes that are distance K in the subtree rooted at target.</p>
</li>
<li><p>If target is in the left branch of node, say at distance L+1, then we should look for nodes that are distance K - L - 1 in the right branch.</p>
</li>
<li><p>If target is in the right branch of node, the algorithm proceeds similarly.</p>
</li>
<li><p>If target isn’t in either branch of node, then we stop.</p>
</li>
</ul>
<p>In the above algorithm, we make use of the auxillary function subtree_add(node, dist) which adds the nodes in the subtree rooted at node that are distance K - dist from the given node.</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def distanceK(self, root, target, K):</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        # Return distance from node to target if exists, else -1</span><br><span class="line">        # Vertex distance: the # of vertices on the path from node to target</span><br><span class="line">        def dfs(node):</span><br><span class="line">            if not node:</span><br><span class="line">                return -1</span><br><span class="line">            elif node is target:</span><br><span class="line">                subtree_add(node, 0)</span><br><span class="line">                return 1</span><br><span class="line">            else:</span><br><span class="line">                L, R = dfs(node.left), dfs(node.right)</span><br><span class="line">                if L != -1:</span><br><span class="line">                    if L == K: ans.append(node.val)</span><br><span class="line">                    subtree_add(node.right, L + 1)</span><br><span class="line">                    return L + 1</span><br><span class="line">                elif R != -1:</span><br><span class="line">                    if R == K: ans.append(node.val)</span><br><span class="line">                    subtree_add(node.left, R + 1)</span><br><span class="line">                    return R + 1</span><br><span class="line">                else:</span><br><span class="line">                    return -1</span><br><span class="line"></span><br><span class="line">        # Add all nodes 'K - dist' from the node to answer.</span><br><span class="line">        def subtree_add(node, dist):</span><br><span class="line">            if not node:</span><br><span class="line">                return</span><br><span class="line">            elif dist == K:</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            else:</span><br><span class="line">                subtree_add(node.left, dist + 1)</span><br><span class="line">                subtree_add(node.right, dist + 1)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        return ans</span><br></pre></td></tr></tbody></table></figure>

<h4 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h4><p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="p199"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1,3,4]</span><br></pre></td></tr></tbody></table></figure>

<p>Explanation: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/solution/">https://leetcode.com/problems/binary-tree-right-side-view/solution/</a></p>
<ol>
<li>My DFS(Recursion)<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line"></span><br><span class="line">        out = []</span><br><span class="line"></span><br><span class="line">        def helper(root, level):</span><br><span class="line"></span><br><span class="line">            nonlocal out</span><br><span class="line"></span><br><span class="line">            if not root:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            if len(out) == level - 1:</span><br><span class="line">                out.append(root.val)</span><br><span class="line"></span><br><span class="line">            helper(root.right, level + 1)</span><br><span class="line">            helper(root.left, level + 1)</span><br><span class="line"></span><br><span class="line">        helper(root, 1)</span><br><span class="line"></span><br><span class="line">        return out</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Algorithm/">#Algorithm</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Leetcode/">#Leetcode</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2021/10/27/docker/">Docker小知识</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2021/10/20/magnificent-century/">宏伟世纪、土耳其继承法、许蕾姆与柯塞姆</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 Morgan Y&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>




<script src="/js/script.js"></script>


    
</body>
</html>