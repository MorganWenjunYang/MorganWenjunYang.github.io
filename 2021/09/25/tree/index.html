<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>初学算法：树 (DFS、BFS、二分查找树) - Morgan Freewoman</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">










<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>



<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-end">
            
            
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            初学算法：树 (DFS、BFS、二分查找树)
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <time datetime="2021-09-25T00:42:15.000Z" itemprop="datePublished">Sep 25 2021</time>
            
        </span>
        
        
        <span class="column is-narrow">
            
            
            15 minutes read (About 2200 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>今天，我们大家欢聚在一起是研究我最喜欢的‘树’，我要敬我的好题目，感谢她，for nothing。我也发自内心地祝愿她，从此以后被我征服。</p>
<span id="more"></span>

<h3 id="EASY"><a href="#EASY" class="headerlink" title="EASY"></a>EASY</h3><h4 id="938-Range-Sum-of-BST"><a href="#938-Range-Sum-of-BST" class="headerlink" title="938. Range Sum of BST"></a>938. Range Sum of BST</h4><p>Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="p938"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">Output: 32</span><br><span class="line">Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursive<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def rangeSumBST(self, root, L, R):</span><br><span class="line">        def dfs(node):</span><br><span class="line">            if node:</span><br><span class="line">                if L &lt;= node.val &lt;= R:</span><br><span class="line">                    self.ans += node.val</span><br><span class="line">                if L &lt; node.val:</span><br><span class="line">                    dfs(node.left)</span><br><span class="line">                if node.val &lt; R:</span><br><span class="line">                    dfs(node.right)</span><br><span class="line"></span><br><span class="line">        self.ans = 0</span><br><span class="line">        dfs(root)</span><br><span class="line">        return self.ans</span><br></pre></td></tr></tbody></table></figure></li>
<li>Iterative<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def rangeSumBST(self, root, L, R):</span><br><span class="line">        ans = 0</span><br><span class="line">        stack = [root]</span><br><span class="line">        while stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            if node:</span><br><span class="line">                if L &lt;= node.val &lt;= R:</span><br><span class="line">                    ans += node.val</span><br><span class="line">                if L &lt; node.val:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">                if node.val &lt; R:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">        return ans</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="543-Diameter-of-Binary-Tree-Similar-to-110"><a href="#543-Diameter-of-Binary-Tree-Similar-to-110" class="headerlink" title="543. Diameter of Binary Tree (Similar to 110)"></a>543. Diameter of Binary Tree (Similar to 110)</h4><p>Given the root of a binary tree, return the length of the diameter of the tree.</p>
<p>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p>The length of a path between two nodes is represented by the number of edges between them.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="p543"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursive<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:</span><br><span class="line">        diameter = 0</span><br><span class="line"></span><br><span class="line">        def longest_path(node):</span><br><span class="line">            if not node:</span><br><span class="line">                return 0</span><br><span class="line">            nonlocal diameter</span><br><span class="line">            # recursively find the longest path in</span><br><span class="line">            # both left child and right child</span><br><span class="line">            left_path = longest_path(node.left)</span><br><span class="line">            right_path = longest_path(node.right)</span><br><span class="line"></span><br><span class="line">            # update the diameter if left_path plus right_path is larger</span><br><span class="line">            diameter = max(diameter, left_path + right_path)</span><br><span class="line"></span><br><span class="line">            # return the longest one between left_path and right_path;</span><br><span class="line">            # remember to add 1 for the path connecting the node and its parent</span><br><span class="line">            return max(left_path, right_path) + 1</span><br><span class="line"></span><br><span class="line">        longest_path(root)</span><br><span class="line">        return diameter</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li>note: the nonlocal diameter</li>
</ul>
<h4 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h4><p>Given the root of a binary tree, invert the tree, and return its root.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="p226"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3,6,9]</span><br><span class="line">Output: [4,7,2,9,6,3,1]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Recursive</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">        if root is None:</span><br><span class="line">            return  </span><br><span class="line"></span><br><span class="line">        root.left = self.invertTree(root.left)</span><br><span class="line">        root.right = self.invertTree(root.right)</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        return root</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iterative (BFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # BFS</span><br><span class="line">    def invertTree(self, root):</span><br><span class="line">        queue = collections.deque([(root)])</span><br><span class="line">        while queue:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            if node:</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        return root</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iterative (DFS)</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # DFS</span><br><span class="line">    def invertTree(self, root):</span><br><span class="line">        stack = [root]</span><br><span class="line">        while stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            if node:</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                stack.extend([node.right, node.left])</span><br><span class="line">        return root</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="101-Symmetric-Tree-Similar-to-100"><a href="#101-Symmetric-Tree-Similar-to-100" class="headerlink" title="101. Symmetric Tree (Similar to 100)"></a>101. Symmetric Tree (Similar to 100)</h4><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="p101"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursie:<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:</span><br><span class="line"></span><br><span class="line">        def isMirror(r1, r2):</span><br><span class="line">            if r1 is None and r2 is None: return True</span><br><span class="line">            if r1 is None or r2 is None: return False</span><br><span class="line">            return (r1.val==r2.val) and isMirror(r1.right,r2.left) and isMirror(r1.left,r2.right)</span><br><span class="line"></span><br><span class="line">        return isMirror(root,root)</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="108-Convert-Sorted-Array-to-Binary-Search-TreeNode-二分法"><a href="#108-Convert-Sorted-Array-to-Binary-Search-TreeNode-二分法" class="headerlink" title="108. Convert Sorted Array to Binary Search TreeNode (二分法)"></a>108. Convert Sorted Array to Binary Search TreeNode (二分法)</h4><p>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.</p>
<p>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="p108_1"><br><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="p108_2"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution: #  Always Choose Left Middle Node as a Root</span><br><span class="line">    def sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:</span><br><span class="line">        def mid(start,end):</span><br><span class="line">            if end &lt; start:</span><br><span class="line">                return None</span><br><span class="line"></span><br><span class="line">            m = (end + start) // 2</span><br><span class="line"></span><br><span class="line">            root = TreeNode(nums[m])</span><br><span class="line">            root.left = mid(start, m-1)</span><br><span class="line">            root.right = mid(m+1, end)</span><br><span class="line"></span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        return mid(0, len(nums)-1)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="897-Increasing-Order-Search-Tree"><a href="#897-Increasing-Order-Search-Tree" class="headerlink" title="897. Increasing Order Search Tree"></a>897. Increasing Order Search Tree</h4><p>Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.</p>
<p>Example<br><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="p897"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>In-order Traversal<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def increasingBST(self, root):</span><br><span class="line">        def inorder(node):</span><br><span class="line">            if node:</span><br><span class="line">                yield from inorder(node.left)</span><br><span class="line">                yield node.val</span><br><span class="line">                yield from inorder(node.right)</span><br><span class="line"></span><br><span class="line">        ans = cur = TreeNode(None)</span><br><span class="line">        for v in inorder(root):</span><br><span class="line">            cur.right = TreeNode(v)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        return ans.right</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li>注意这个制造iterator来实现in-order traversal的方法</li>
</ul>
<ol start="2">
<li>Traversal with Relinking<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def increasingBST(self, root):</span><br><span class="line">        def inorder(node):</span><br><span class="line">            if node:</span><br><span class="line">                inorder(node.left)</span><br><span class="line">                node.left = None</span><br><span class="line">                self.cur.right = node</span><br><span class="line">                self.cur = node</span><br><span class="line">                inorder(node.right)</span><br><span class="line"></span><br><span class="line">        ans = self.cur = TreeNode(None)</span><br><span class="line">        inorder(root)</span><br><span class="line">        return ans.right</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572. Subtree of Another Tree"></a>572. Subtree of Another Tree</h4><p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</p>
<p>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</p>
<p>Example<br><img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" alt="p572"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,4,5,1,2], subRoot = [4,1,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Time O(N*T) N,T分别是两个tree的height</li>
</ol>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSubtree(self, s: TreeNode, t: TreeNode) -&gt; bool:</span><br><span class="line">        if not s:</span><br><span class="line">            return False</span><br><span class="line">        if self.isSameTree(s, t):</span><br><span class="line">            return True</span><br><span class="line">        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)</span><br><span class="line"></span><br><span class="line">    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:</span><br><span class="line">        if p and q:</span><br><span class="line">            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)</span><br><span class="line">        return p is q</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>Advanced approach, O(|s| + |t|) (Merkle hashing):<br>For each node in a tree, we can create node.merkle, a hash representing it’s subtree.<br>This hash is formed by hashing the concatenation of the merkle of the left child, the node’s value, and the merkle of the right child. Then, two trees are identical if and only if the merkle hash of their roots are equal (except when there is a hash collision.) From there, finding the answer is straightforward: we simply check if any node in s has node.merkle == t.merkle</li>
</ol>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def isSubtree(self, s, t):</span><br><span class="line">    from hashlib import sha256</span><br><span class="line">    def hash_(x):</span><br><span class="line">        S = sha256()</span><br><span class="line">        S.update(x)</span><br><span class="line">        return S.hexdigest()</span><br><span class="line"></span><br><span class="line">    def merkle(node):</span><br><span class="line">        if not node:</span><br><span class="line">            return '#'</span><br><span class="line">        m_left = merkle(node.left)</span><br><span class="line">        m_right = merkle(node.right)</span><br><span class="line">        node.merkle = hash_(m_left + str(node.val) + m_right)</span><br><span class="line">        return node.merkle</span><br><span class="line"></span><br><span class="line">    merkle(s)</span><br><span class="line">    merkle(t)</span><br><span class="line">    def dfs(node):</span><br><span class="line">        if not node:</span><br><span class="line">            return False</span><br><span class="line">        return (node.merkle == t.merkle or</span><br><span class="line">                dfs(node.left) or dfs(node.right))</span><br><span class="line"></span><br><span class="line">    return dfs(s)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="110-Balanced-Binary-Tree-Similar-to-543"><a href="#110-Balanced-Binary-Tree-Similar-to-543" class="headerlink" title="110. Balanced Binary Tree (Similar to 543)"></a>110. Balanced Binary Tree (Similar to 543)</h4><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<p>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p>
<p>Example<br><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="p110"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursive<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # Return whether or not the tree at root is balanced while also returning</span><br><span class="line">    # the tree's height</span><br><span class="line">    def isBalancedHelper(self, root: TreeNode) -&gt; (bool, int):</span><br><span class="line">        # An empty tree is balanced and has height -1</span><br><span class="line">        if not root:</span><br><span class="line">            return True, -1</span><br><span class="line"></span><br><span class="line">        # Check subtrees to see if they are balanced.</span><br><span class="line">        leftIsBalanced, leftHeight = self.isBalancedHelper(root.left)</span><br><span class="line">        if not leftIsBalanced:</span><br><span class="line">            return False, 0</span><br><span class="line">        rightIsBalanced, rightHeight = self.isBalancedHelper(root.right)</span><br><span class="line">        if not rightIsBalanced:</span><br><span class="line">            return False, 0</span><br><span class="line"></span><br><span class="line">        # If the subtrees are balanced, check if the current tree is balanced</span><br><span class="line">        # using their height</span><br><span class="line">        return (abs(leftHeight - rightHeight) &lt; 2), 1 + max(leftHeight, rightHeight)</span><br><span class="line"></span><br><span class="line">    def isBalanced(self, root: TreeNode) -&gt; bool:</span><br><span class="line">        return self.isBalancedHelper(root)[0]</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="100-Same-Tree-Similar-to-101"><a href="#100-Same-Tree-Similar-to-101" class="headerlink" title="100. Same Tree (Similar to 101)"></a>100. Same Tree (Similar to 101)</h4><p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="p100"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p = [1,2,1], q = [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursion<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:</span><br><span class="line">        def isSame(t1, t2):</span><br><span class="line">            if t1 is None and t2 is None:</span><br><span class="line">                return True</span><br><span class="line">            if t1 is None or t2 is None:</span><br><span class="line">                return False</span><br><span class="line"></span><br><span class="line">            return t1.val == t2.val and isSame(t1.left, t2.left) and isSame(t1.right, t2.right)</span><br><span class="line"></span><br><span class="line">        return isSame(p, q)</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="235-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Tree"></a>235. Lowest Common Ancestor of a Binary Tree</h4><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Example<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="p235"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>Recursive (Better | Time: O(N) &amp; Space O(N))</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span><br><span class="line">        # Value of current node or parent node.</span><br><span class="line">        parent_val = root.val</span><br><span class="line"></span><br><span class="line">        # Value of p</span><br><span class="line">        p_val = p.val</span><br><span class="line"></span><br><span class="line">        # Value of q</span><br><span class="line">        q_val = q.val</span><br><span class="line"></span><br><span class="line">        # If both p and q are greater than parent</span><br><span class="line">        if p_val &gt; parent_val and q_val &gt; parent_val:    </span><br><span class="line">            return self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        # If both p and q are lesser than parent</span><br><span class="line">        elif p_val &lt; parent_val and q_val &lt; parent_val:    </span><br><span class="line">            return self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        # We have found the split point, i.e. the LCA node.</span><br><span class="line">        else:</span><br><span class="line">            return root</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Iterative (Better | Time: O(N) &amp; Space O(1))<br>In essence of it the problem is iterative, it just wants us to find the split point. The point from where p and q won’t be part of the same subtree or when one is the parent of the other</p>
</li>
</ol>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        """</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span><br><span class="line"></span><br><span class="line">        # Value of p</span><br><span class="line">        p_val = p.val</span><br><span class="line"></span><br><span class="line">        # Value of q</span><br><span class="line">        q_val = q.val</span><br><span class="line"></span><br><span class="line">        # Start from the root node of the tree</span><br><span class="line">        node = root</span><br><span class="line"></span><br><span class="line">        # Traverse the tree</span><br><span class="line">        while node:</span><br><span class="line"></span><br><span class="line">            # Value of current node or parent node.</span><br><span class="line">            parent_val = node.val</span><br><span class="line"></span><br><span class="line">            if p_val &gt; parent_val and q_val &gt; parent_val:    </span><br><span class="line">                # If both p and q are greater than parent</span><br><span class="line">                node = node.right</span><br><span class="line">            elif p_val &lt; parent_val and q_val &lt; parent_val:</span><br><span class="line">                # If both p and q are lesser than parent</span><br><span class="line">                node = node.left</span><br><span class="line">            else:</span><br><span class="line">                # We have found the split point, i.e. the LCA node.</span><br><span class="line">                return node</span><br></pre></td></tr></tbody></table></figure>

<h4 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a>501. Find Mode in Binary Search Tree</h4><p>Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.</p>
<p>If the tree has more than one mode, return them in any order.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than or equal to the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Example<br><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="p501"></p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>Recursive<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMode(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        self.mode = 0</span><br><span class="line">        d = {}</span><br><span class="line">        out = []</span><br><span class="line"></span><br><span class="line">        self.traverse(root, d)</span><br><span class="line"></span><br><span class="line">        for node, count in d.items():</span><br><span class="line">            if count == self.mode:</span><br><span class="line">                out.append(node)</span><br><span class="line"></span><br><span class="line">        return out</span><br><span class="line"></span><br><span class="line">    def traverse(self, root: TreeNode, d: dict):</span><br><span class="line">        if not root: return</span><br><span class="line">        d[root.val] = d.get(root.val, 0) + 1</span><br><span class="line">        self.mode = max(self.mode, d[root.val])</span><br><span class="line">        self.traverse(root.left, d)</span><br><span class="line">        self.traverse(root.right, d)</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
</body></html>
    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Algorithm/">#Algorithm</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Leetcode/">#Leetcode</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2021/09/25/binary-search/">初学算法：二分法查找</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2021/09/22/sql-sequence/">SQL的执行顺序</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 Morgan Y&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>




<script src="/js/script.js"></script>


    
</body>
</html>