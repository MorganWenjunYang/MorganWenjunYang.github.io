{"pages":[],"posts":[{"title":"初学算法：DP & Backtracking 动态规划和回溯问题","text":"以下是leetcode中，我觉得难度适中的几道动态规划和回溯问题，在这里记录下来，以供未来复习之用。","link":"/2021/07/26/DP/"},{"title":"印度神话梳理与印度起源的宗教们","text":"印度神话对于小时候只看过中国神话、希腊罗马神话的我，可谓是一个极其新鲜的话题，只可惜年龄导致的记忆力衰退让我即使看了三遍书，也还是不能记得大概。所以写一个关于印度神话的memo，对于我掌握印度神话的脉络还是非常有必要的。篇幅不宜过长，否则也不利于经常复习。 本篇主要包含以下几个部分： 摩诃婆罗多 ~ 薄伽梵歌 罗摩衍那 沙恭达罗 宗教与民族","link":"/2021/05/19/India/"},{"title":"音乐随感","text":"瞎说，胡说，想到什么说什么，勿认真 Aaliyah Age Ain’t Nothing But A Number Alicia Keys The Diary of Alicia Keys As I Am Aimer After Dark Amy Winehouse Frank Annie Lennox Medusa Beyonce Dangerously in Love Black Box Recorder The Facts Of Life Passionoia Buika Nina de Fuego Carol King Tapestry Erykah Badu Live Mama’s Gun Father John Misty Pure Comedy God’s Favorite Customer Flower 花时计 Florence &amp; The Machine Ceremonials How Big, How Blue, How Beautiful Fugees The Score H.E.R H.E.R I Used To Know Her The Internet Ego Death Hive Mind Jill Scott Who Is Jill Scott Karyn White Karyn White Lady Gaga Artpop Joanne Lana Del Rey Born to Die Ultraviolence Honeymoon Lust For Life Norman Fucking Rockwell Lauryn Hill The Miseducation of Luaryn Hill Lykki Li I Never Learn Marina And The Diamond Electra Heart Mary J Mlige The Breakthrough MO No Mythologies To Follow When I Was Young Forever Neverlend Sade Diamond Life SWV It’s About Time SZA Ctrl Z Tinashe Aquarius Reverie Black Water TLC Crazysexycool Toni Braxton Secrets VanJess Homegrown Silk Canvas 柴田淳 COVER 70’s 幸田来未 Trick 一青窈 月天心 元ちとせ カッシーニ 椎名林檎 無罪モラトリアム 平成風俗 混搭专/Soundtrack Waiting To Exhale The Witcher 3 银翼杀手","link":"/2021/07/26/Music-general/"},{"title":"你老婆变成了怪物？真巧，我的也是","text":"","link":"/2021/05/18/Monster-Wife/"},{"title":"Podcast","text":"","link":"/2021/07/26/Podcast/"},{"title":"R Markdown 模板自动生成文件","text":"","link":"/2021/05/20/RMD-generate-document/"},{"title":"用Docker部署Flask到阿里云","text":"可能是最简单的部署方式。 当在flask里使用app.run（）的时候在运行flask的时候，我们只是将app部署到了一个测试环境，而真正将我们的app分享给更多人使用，需要经过更多的步骤。 首先简单讲一下我对docker的理解（完全不一定准确）。dockerhub就如同GitHub一样，是一个托管平台，不同点在于github托管的是代码，dockerhub托管的则是镜像。Github的代码clone到本地后并不能直接使用，比如当在代码中import numpy as np或者library(tidyr)，而你的环境中并没有这个包时，显然这些代码并不能一下子顺利的运行，你需要先下载所有依赖的包，另外也可能存在潜在的路径问题。对于docker来说，它所保存的不仅是代码，而是将整个代码和它运行的环境打包成一个镜像，用户下载镜像，得到的就是一个独立自洽的小宇宙（其实是小宇宙模板，我们之后再说），可以不经任何处理，直接使用。 与镜像-image紧密相连的一个概念是容器-container。 镜像只是一个模板，从这个模板我们可以创造出很多容器，每个容器内部都是一样的环境，运行一样的程序。也就是说，只要每个用户都将同样的镜像下载到本地，并在此之上运行容器，那么我们就可以保证所有用户都在一样的环境下运行一样的程序。 来详细看一下实际操作。 下载Gunicorn和Gevent两个包：1pip install gunicorn gevent 在应用目录为gunicorn建立配置文件，/gunicorn.conf.py，内容如下：123workers = 5 # 定义同时开启的处理请求的进程数量，根据网站流量适当调整worker_class = \"gevent\" # 采用gevent库，支持异步处理请求，提高吞吐量bind = \"0.0.0.0:80\" 可以使用gunicorn命令来测试是否可以正确运行，命令如下，打开网址127.0.0.1:80，将会打开我们的网站。1gunicorn start:app -c gunicorn.conf.py 下载linux cmd对于win系统来说，首先需要下载windows terminal和ubuntu，这样我们就可以在win系统上使用linux cmd。请follow如下链接，在ubuntu中下载dockerUbuntu Docker 安装 创建requirements文件为该应用创建一个 requirements.txt 文件，以便容器里面 python 环境的安装：/requirements.txt。e.g. 如果你的项目用到了flask，numpy，pandas，那该文件就会像这样1234flasknumpypandas...... 建立Dockerfile在真正把我们的app封装成镜像之前，还需要在应用目录建立Dockerfile文档（注意，这个文件不是txt，是一个没有扩展名的文件）。Dockerfile的内容包括复制文件到容器内路径，需要在容器内命令行run的指令等。Dockerfile的细节请参考如何编写dockerfile一个简单的例子如下：123456789FROM python:3.6WORKDIR /Project/demoCOPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .CMD [\"gunicorn\", \"start:app\", \"-c\", \"./gunicorn.conf.py\"] 其中，第二行 WORKDIR 后面写的是要部署到服务器上的路径，最后一行里面的 start 是我们上面写的 python 启动文件名，app 是启动文件里面要启动的应用名（变量名）也就是说在这个例子里，你的flask主程序/启动程序应该叫做start.py，在这个py文件中，你定义的flask app名字叫做app。当容器运行时，它会自动地下载requirements文件中指定的包，复制所有文件到容器根目录，并在容器cmd中按照配置文件上线flask程序。 生成镜像在linux cmd中进入到flask项目的目录，输入1sudo docker build -t 'nameOfYourImage' 回车执行后，输入sudo docker images，可以看到新生成的镜像 上传至镜像托管平台（以dockerhub为例）dockerhub是一个镜像托管平台，和github一样，如果你要在另一台电脑使用代码，你需要执行一个上传下拉的操作。（当然你也可以使用其他镜像托管平台）首先注册dockerhub账号，免费用户将只能拥有一个repository，也就是只能存储一个镜像（和它的不同版本）。这时候继续回到本地linux cmd，我们需要在本地使用docker login登录dockerhub，成功登陆后，将我们之前建立的镜像根据dockerhub的账户名和repository名重命名，并打上tag。1docker tag previousImageID(SHA) yourAccountName/youRepoName:Tagname 接下来使用，像github一样，使用docker push yourAccountName/youRepoName:Tagname将我们的镜像push到dockerhub。 在服务器下载docker，下拉镜像并运行容器不管是centOS，aliyun linux还是ubuntu，在你的服务器上下载docker，对于aliyun linux来说可能是podman。但不论如何，你需要一个镜像管理工具。以下以podman为例：用podman pull yourAccountName/youRepoName:Tagname从dockerhub拉取镜像到本地接下来用如下代码，基于镜像建立容器，并让容器运行起来，上线我们的flask app：1podman run -d -p 80:80 --name imageName(or SHA) containerName 此时输入podman ps，可以看到我们的容器正在运行。注意 -p 80:80 说明我们把容器的80端口映射到服务器的80端口。还记得我们在第一步创建的配置文件将我们的程序绑定到80端口，所以这里我们需要把容器的80端口映射出去，我们才能够在外部访问它，这个服务器端口不一定是80，可以是任何你希望的端口，但注意要在设置服务器时把这个端口开放给外部使用。 That’s it! Have fun with docker! 参考网址： Flask + Docker 无脑部署新手教程 docker-image container 基本操作 -常用命令 网络调试指令ping、telnet、curl docker系列学习（二）：Docker + Flask 例子 （全系列值得一看） easybook: Docker 从入门到实践 Why Does My Docker Container Stop? Container exit code dockerfile——EXPOSE和端口映射参数-p、-P总结 如何编写dockerfile 如何上传镜像到dockerhub cron测试器 cron范例 vim指南 Linux定时运行Python脚本 从本地发送文件到云服务器–ECS云助手","link":"/2021/08/06/flask-docker/"},{"title":"Hexo+Github 超简易个人博客搭建","text":"","link":"/2021/05/19/Tech-Hexo/"},{"title":"Leetcode上的SQL题（Part 1）","text":"本篇整理Leetcode SQL当中比较有代表性、比较易错的某些题目，以供未来学习、复习之用。 题目1179. Reformat Department Table:Table: Department Column Name Type id int revenue int month varchar (id, month) is the primary key of this table.The table has information about the revenue of each department per month.The month has values in [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”]. Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month. Answer: 1234567891011121314151617selectid,sum(case when month='jan' then revenue else null end) as Jan_Revenue,sum(case when month = 'feb' then revenue else null end) as Feb_Revenue,sum(case when month = 'mar' then revenue else null end) as Mar_Revenue,sum(case when month = 'apr' then revenue else null end) as Apr_Revenue,sum(case when month = 'may' then revenue else null end) as May_Revenue,sum(case when month = 'jun' then revenue else null end) as Jun_Revenue,sum(case when month = 'jul' then revenue else null end) as Jul_Revenue,sum(case when month = 'aug' then revenue else null end) as Aug_Revenue,sum(case when month = 'sep' then revenue else null end) as Sep_Revenue,sum(case when month = 'oct' then revenue else null end) as Oct_Revenue,sum(case when month = 'nov' then revenue else null end) as Nov_Revenue,sum(case when month = 'dec' then revenue else null end) as Dec_Revenuefrom departmentgroup by idorder by id Insights:用case when … then … else … end 避免使用多个select来建立多个新的column 题目180. Consecutive Numbers:Table: Logs Column Name Type id int num varchar id is the primary key for this table.Write an SQL query to find all numbers that appear at least three times consecutively.Return the result table in any order. Answer: 12345678910selectdistinct l1.num as ConsecutiveNumsfromLogs l1,Logs l2,Logs l3where l1.id = l2.id - 1and l2.id = l3.id - 1and l1.num = l2.numand l2.num = l3.num Insights:连续天数/连续数字问题可以先做Cartesian Product，然后再用where筛选符合条件的记录。但是这样的话，空间上是否占用过多？ 题目196. Delete Duplicate Emails:Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. Id Email 1 john@example.com 2 bob@example.com 3 john@example.com Id is the primary key column for this table.For example, after running your query, the above Person table should have the following rows: Id Email 1 john@example.com 2 bob@example.com Your output is the whole Person table after executing your sql. Use delete statement. Answer: 123456789delete from Personwhere Id in(select Id from( select Id, rank() over(partition by Email order by Id) as myrank from Person)as twhere myrank&gt;=2) Insights:Delete from … where … 题目1132. Reported Posts II:Table: Actions Column Name Type user_id int post_id int action_date date action enum extra varchar There is no primary key for this table, it may have duplicate rows.The action column is an ENUM type of (‘view’, ‘like’, ‘reaction’, ‘comment’, ‘report’, ‘share’).The extra column has optional information about the action such as a reason for report or a type of reaction. Table: Removals Column Name Type post_id int remove_date date post_id is the primary key of this table.Each row in this table indicates that some post was removed as a result of being reported or as a result of an admin review. Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places. Answer: 123456789101112select round(avg(rm/all_rp)*100,2) as average_daily_percentfrom(selectcount(distinct a.post_id) as all_rp,count(distinct r.post_id) as rmfrom Actions aleft join Removals ron a.post_id = r.post_idwhere action='report' and extra = 'spam'group by action_date)t Insights:注意left join而不是join，避免不在actions内的记录被count计算到 题目1355. Activity Participants:Table: Friends Column Name Type id int name varchar activity varchar id is the id of the friend and primary key for this table.name is the name of the friend.activity is the name of the activity which the friend takes part in. Table: Activities Column Name Type id int name varchar id is the primary key for this table.name is the name of the activity. Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants. Return the result table in any order. Each activity in table Activities is performed by any person in the table Friends. Answer: 12345select activityfrom friendsgroup by activityhaving count(*)&gt; (select count(*) from friends group by activity order by 1 limit 1)and count(*)&lt; (select count(*) from friends group by activity order by 1 desc limit 1) 或者 123456SELECT activityFROM (SELECT activity, DENSE_RANK () OVER (ORDER BY COUNT(*) DESC) RK, DENSE_RANK () OVER (ORDER BY COUNT(*)) RK2FROM FriendsGROUP BY 1) TEMPWHERE rk != 1 and rk2 !=1 Insights: nested query 的使用的区别 不是题干给出的每张表都有用 双向窗口函数 dense_rank与rank的区别 题目602. Friends Requests II: Who has the most friends:In social network like Facebook or Twitter, people send friend requests and accept others’ requests as well. Table request_accepted requester_id accepter_id accept_date 1 2 2016_06-03 1 3 2016-06-08 2 3 2016-06-08 3 4 2016-06-09 This table holds the data of friend acceptance, while requester_id and accepter_id both are the id of a person. Write a query to find the the people who has most friends and the most friends number under the following rules: It is guaranteed there is only 1 people having the most friends.The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value.For the sample data above, the result is: Result table: id num 3 3 The person with id ‘3’ is a friend of people ‘1’, ‘2’ and ‘4’, so he has 3 friends in total, which is the most number than any others.Follow-up:In the real world, multiple people could have the same most number of friends, can you find all these people in this case? Answer: 1234567891011121314select requester_id as id, count(*) as numfrom(select requester_id, accepter_idfromrequest_accepted r1unionselect accepter_id, requester_idfromrequest_accepted r2)tgroup by requester_idorder by num desclimit 1 Insights:union all: keep all the duplicate entryunion: only keep the distinct ones 题目1327. List the Products Ordered in a Period:Table: Products Column Name Type product_id int product_name varchar product_category varchar product_id is the primary key for this table.This table contains data about the company’s products. Table: Orders Column Name Type product_id int order_date date unit int There is no primary key for this table. It may have duplicate rows.product_id is a foreign key to Products table.unit is the number of products ordered in order_date. Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.Return result table in any order. Answer: 1234567select product_name, sum(unit) as unitfrom Orders oleft join Products po.product_id = p.product_idwhere order_date between '2020-02-01' and '2020-02-29'group by product_namehaving unit &gt;= 100 Insights:between是两边包含的一个关系表达式 题目1398. Customers Who Bought Product A and B but Not C:Table: Customers Column Name Type customer_id int customer_name varchar customer_id is the primary key for this table.customer_name is the name of the customer. Table: Orders Column Name Type order_id int customer_id int product_name varchar order_id is the primary key for this table.customer_id is the id of the customer who bought the product “product_name”. Write an SQL query to report the customer_id and customer_name of customers who bought products “A”, “B” but did not buy the product “C” since we want to recommend them buy this product. Return the result table ordered by customer_id. Answer: 1234567891011select * from Customerswhere customer_id in(select distinct customer_id from Orderswhere product_name=\"A\")andcustomer_id in(select distinct customer_id from Orderswhere product_name=\"B\")and customer_id not in(select distinct customer_id from Orderswhere product_name=\"C\") Insights:nested query 题目1045. Customers Who Bought All Products:Table: Customer Column Name Type customer_id int product_key int product_key is a foreign key to Product table. Table: Product Column Name Type product_key int product_key is the primary key column for this table. Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table. Return the result table in any order. Answer: 1234select customer_idfrom Customer cgroup by customer_idhaving count(distinct product_key) = (select count(*) from Product) Insights:做题时要注意distinct是否会影响count的结果，并根据实际情况决定加或者不加 题目262. Trips and Users:Table: Trips Column Name Type Id int Client_Id int Driver_Id int City_Id int Status enum Request_at date Id is the primary key for this table.The table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are foreign keys to the Users_Id at the Users table.Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). Table: Users Column Name Type Users_Id int Banned enum Role enum Users_Id is the primary key for this table.The table holds all users. Each user has a unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).Status is an ENUM type of (‘Yes’, ‘No’). Write a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between “2013-10-01” and “2013-10-03”. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day. Return the result table in any order. Round Cancellation Rate to two decimal points. Answer: 123456789select Request_at as Day,round(sum(case when Status = 'cancelled_by_driver' or Status = 'cancelled_by_client' then 1 else 0 end)/count(*),2) as 'Cancellation Rate'from Trips twhere Client_Id not in (select Users_Id from Users where Banned='Yes')and Driver_Id not in (select Users_Id from Users where Banned='Yes')and Request_at between '2013-10-01' and '2013-10-03'group by Request_at Insights:when Status = ‘cancelled_by_driver’ or Status = ‘cancelled_by_client’也可以写成 Status in (“cancelled_by_driver”,”cancelled_by_client”) 题目615. Average Salary: Departments VS Company:Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company’s average salary. Table: salary id employee_id amount pay_date 1 1 9000 2017-03-31 2 2 6000 2017-03-31 3 3 10000 2017-03-31 4 1 7000 2017-02-28 5 2 6000 2017-02-28 6 3 8000 2017-02-28 The employee_id column refers to the employee_id in the following table employee. employee_id department_id 1 1 2 2 3 2 So for the sample data above, the result is: pay_month department_id comparison 2017-03 1 higher 2017-03 2 lower 2017-02 1 same 2017-02 2 same Answer: 12345678910111213select distinct date_format(pay_date, '%Y-%m') as pay_month,department_id,(case when dept_avg&lt; company_avg then \"lower\" when dept_avg&gt; company_avg then \"higher\" else \"same\" end) as comparisonfrom(select s.employee_id, e.department_id,pay_date,amount, avg(amount) over (partition by pay_date) as company_avg , avg(amount) over (partition by pay_date, department_id) as dept_avgfrom salary as sjoin employee as eon s.employee_id=e.employee_id) as tmp Insights: case when … then … when … then … else … data_format() 改变日期格式，这里也可以使用substr(pay_data,1,7) 活用窗口函数，本体为聚合函数的窗口函数 窗口函数 窗口函数语法 12&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;) &lt;窗口函数&gt;的位置，可以放以下两种函数： 1） 专用窗口函数，比如rank, dense_rank, row_number等 2） 聚合函数，如sum. avg, count, max, min等 窗口函数有以下功能： 1）同时具有分组（partition by）和排序（order by）的功能 2）不减少原表的行数，所以经常用来在每组内排名 注意事项 窗口函数原则上只能写在select子句中 窗口函数使用场景 1）业务需求“在每组内排名”，比如： 排名问题：每个部门按业绩来排名 topN问题：找出每个部门排名前N的员工进行奖励","link":"/2021/07/26/leetcode-sql/"},{"title":"公主们的战国","text":"织田信长、丰臣秀吉、德川家康，日本战国历史无法绕开的三个人。东亚历史往往是男人戏，女人永远在暗处。而日本战国也正有这样一条女性的暗线，串起三位豪杰领衔主演的乱世风云。 故事从年纪最长的织田信长说起。织田家族是尾张地方的豪强，家族以美貌闻名，男帅女美。信长本人年轻时是有名的不正经帅哥，而妹妹阿市也是名动天下的美女。古代的贵族女性的普遍经历-政治婚姻，使得市姬与近江豪强浅井家族的浅井长政成婚。浅井长政是一个相对的好人，两人非常恩爱，诞生了三个女儿和另外的两个男孩。 说到这里，大家也应该都明白了，这三个女孩就是这个故事的主角。迎接她们的是波澜四起的人生。 三个女孩，长女茶茶，次女初，小女江，生长在一个有爱的家庭当中，度过了相当不错的童年。 当然，乱世之所以是乱世，正因为一个人身处乱世就算什么错也不犯，麻烦也会自己找上门来。我们略去其中波折，只要知道浅井长政或为利，或为名，或为荣誉，加入了信长的敌对阵营，最终不敌当时还姓羽柴的丰臣秀吉，不得已在居城小谷城与父亲一同切腹自尽，留下儿女妻子给妻兄信长。长男被处刑，次男出遁，三个女孩和阿市却得以在织田家继续生活。 传言道，市姬的美貌得到了织田家大老新贵们的垂涎，其中就有家老代表柴田胜家与新贵代表羽柴秀吉，两人都对市姬抱有极大的兴趣。但信长最终选择了胜家作为市姬的下一个结婚对象和拉拢对象。 战国时代最著名的诗，莫过于织田信长在本能寺的绝命诗： 思えば此の世は常の住処にあらず草の葉におく白露水に宿る月より猶あやし金谷に花を詠じ栄華はさきを立って無常の風にさそわるる南楼の月を弄ぶ輩も月に先だって有為の雲に隠れり人間五十年下天の中をくらぶれば夢幻のごとくなり一度生を受け滅せぬ者のあるべきか滅せぬ者のあるべきか是を菩提の種と思ひ定めざらんは口惜しかりし次第ぞと思ひ定め急ぎ都へ上りつつ敦盛の御首を見れば物憂さに獄門よりも盗み取り我が宿に帰り御僧を供養し無常の煙となし申し 中译如下： 常思人世漂流无常譬如朝露水中映月刹那繁华瞬间即逝风流人物今非昔比人生五十年莫非熙熙攘攘浮生幻梦名垂青史功败湮灭只是宿命因果一念之间有何可惜急至京都忧心难忍狱门示众敦盛之首窃而归家传僧供奉叹息如烟人间无常 死亡是有其美感的。不管英雄或枭雄，一个善终或是在某地郁郁而终，总是觉得和他们波澜壮阔的一生不太相配，而命运却慷慨给信长的人生一个足够戏剧的结尾。本能寺之变一直是很多影视剧、文学作品常常涉及的故事。枭雄，叛徒，刀剑，火光，壮士殒命，无一不是充满戏剧性冲突性的元素，在吞噬一切的火光中结束璀璨的一生，不失为配得上枭雄的结局。 在信长死后，织田家的势力陷入了分崩离析，这一次，柴田胜家与羽柴秀吉走到了对立面，而秀吉又一次获得了胜利。柴田胜家和市姬在天守阁自杀身亡，将三个女孩托付给秀吉，并告诉他，这是先主君信长的外甥女，希望他好好照顾。于是，三姐妹又一次改换门庭，寄人篱下，成为秀吉的养女。 逐个击败政敌后，秀吉的权力来到了巅峰，信长不曾做到的关白、太政大臣，他一一收归己有。也许是我的刻板印象吧，当一个男人拥有了所有，他对没有征服的人/事的渴望就会达到顶峰。传闻市姬的长女茶茶和她十分相似，这似乎可以解释秀吉染指茶茶的原因，又或者茶茶也只不过是他征服的一个个高门贵女之一。总而言之，茶茶成为了秀吉的侧室，号为淀殿，说到这里，不得不说秀吉也是惯犯了，之前的另一位养女——好兄弟前田利家之女也被他收作了侧室。茶茶与其他人的不同除了肖似市姬之外，最重要的是她给秀吉带来了继承人。秀吉曾有一子名秀胜，但不幸夭折，过后多年毫无子息，秀吉因而将外甥三好秀次收为养子。在秀吉五十二岁时，淀殿/茶茶生下了儿子鹤松，秀吉为其取小名为‘舍’，以期用一个贱命为孩子消灾解难，而不幸的是鹤松三岁便夭折了。这个孩子的降生让秀吉本已属意秀次，决定好好培养秀次的心又动摇了。四年后，淀殿又生下了秀赖。这一次，丰臣政权的矛盾开始真正显露出来。 这里想要推荐一部日本历史小说——《丰臣家的人们》，本书出自历史小说大师司马辽太郎之手，书中以丰臣秀吉身边的几个人为主题，从不同人的不同命运轨迹，描绘了丰臣政权的兴衰。其中下场最悲惨，人生起落之大，要数秀吉的外甥秀次了。秀次本就是中人之姿，如果时代没有造就他的叔父，他也许就可以做一个普通的农家子弟，在乱世之中过尽可能普通的生活。然而，命运让他做了名家三好家的继承人，又继而成为丰臣家族的继承人，就注定了秀次这一生不可能平静的度过。正如名言所说，“命运给予的礼物早在暗中标好了价格”，而秀次的礼物需要用性命来偿还。 可以想见，当秀吉的亲生儿子出生，秀吉又身体康健，秀次作为丰臣家族继承人的身份是岌岌可危的。最后处决了关白秀次一家所有人","link":"/2021/05/20/himesama/"},{"title":"百合文学影视的机锋","text":"要探讨百合文学影视，可以出发的角度不可谓不多，而本文主要想聊聊以下几个方面： 爱情的障碍 男性角色的刻画 情色场面的描绘 说起百合影视，网络上讨论度、风评较好的作品不得不提燃烧女子的肖像、卡罗尔、小姐/指匠琴挑这四部。这四部作品各有所长，都有让人难忘的优秀画面和剧情。 简单总括一下我对四部片子的感受。 燃烧女子的肖像打造了一个纯粹女性、没有任何男性的孤岛，当片尾取画的男子出现时，正是这个伊甸园被打破的时刻。不知道是不是女性角色多以及女导演拍摄或是我身为女性带来的一种特质，我总能在画面中，觉察到情绪的流动，眼神、嘴角、眉梢，情绪一点一点流露出来。真正动人的不是大声说出的爱，而是隐藏在平静外表下涌动的感情，克制方才更加性感，过于直白反倒到人胃口。 我特别喜欢两位主角一站一坐对于主体客体的一番讨论，也许正是这种画画设定带来的安静的审视，让她们即使没有很多的接触，也能格外的了解彼此。当然，两位女主的爱情也是片中反复提及的俄耳普斯与欧律提刻的故事的一种投射。俄耳普斯做了诗人的选择，选择记住欧律提刻的美，于是再也没有在阳间见到欧律提刻。 卡罗尔 其他有一些有独到亮点的百合电影","link":"/2021/05/18/lily/"},{"title":"物语杂谈","text":"源氏物语平家物语落洼物语伊势物语交野少将物语雨月物语竹取物语春雨物语","link":"/2021/05/20/monogatari/"},{"title":"鬼才李碧华的审美取向","text":"七成饱，三分醉，十足收成；过上等生活，付中等劳力，享下等情欲。 李碧华也许是上世纪作品商业化最成功的几位作家之一。虽然不比‘飞雪连天射白鹿，笑书神侠倚碧鸳’的金庸先生，以及一代女孩追捧的琼瑶女士，但将李碧华的作品一一数来，也足够令人赞叹此人超绝的才华。 霸王别姬 青蛇 胭脂扣 古今大战秦俑情 生死桥 潘金莲的前世今生 饺子 川岛芳子 … 上世纪华语圈的帅哥美女们纷纷入戏，成为李碧华笔下的痴男怨女，在大荧幕上开始一场又一场充满无法挣脱的宿命感的纠缠。 如果用几个词来概括李碧华笔下的情，我觉得该是“痴狂”和“决绝”。李女士要的永远是为爱痴狂，永远保持烈火烹油、鲜花着锦之盛。爱情一旦过渡到柴米油盐，就如从华清池跌入泥潭，从纯白无暇到满身泥泞，人会开始真正审视自己的处境，从此感情势必就失去了一切激情和魅力。为了永远保持这份激情，不如在最顶峰的时候，一气把它斩断，要人永远记住最炙热最颠狂的时分。 胭脂扣，十二少与如花，张国荣和梅艳芳，如果真能双双殉情也罢，怕就怕一人独活下来，苟且偷生。","link":"/2021/05/18/LBH/"},{"title":"TicketMaster刷票器","text":"疫情期间奋发图强，写了一个专门爬取东航余票的程序，但因为是第一次接触，所以做的非常粗糙，也毫不具有实用性，所以现在想要改进/重塑这个程序，使之能够在实际生活中使用。 Previous：持续爬取网站余票信息，如果有符合条件的，即发送消息到指定邮箱，提醒购票。这里就存在几个问题。 东航有反爬机制，有很大概率被封IP, 而且封一次长达几天之久。 使用IP代理大部分需要付费，免费IP的质量很差，有效时间也很多，需要额外维护程序来抓取新的免费IP，并持续的检查IP是否有效。 发送提醒购票信息这种操作并不及时，不能解决我们抢票的需求。需要实现以下功能：当程序发现可选余票时，要模仿点击操作，将该票锁住。","link":"/2021/08/06/ticketmaster/"},{"title":"初学算法：链接表题目汇总","text":"以下是leetcode中，我觉得难度适中的几道链接表题目，在这里记录下来，以供未来复习之用。 Leetcode: 19 Leetcode: 24 Leetcode: 61 Leetcode: 92 Leetcode: 143","link":"/2021/07/26/Linked-List/"},{"title":"Streamlit的基本操作","text":"Streamlit是目前为止，我觉得最简易、最不用花心思在呈现上的一个webapp包，让开发者可以更关注内容，而不是外观展现。本文旨在记录Streamlit的基本操作，以期建立一个模板，以供未来长期反复使用。","link":"/2021/08/06/streamlit/"},{"title":"Dash-intro","text":"","link":"/2021/08/16/Dash-intro/"},{"title":"spark_intro","text":"本篇主要是《Spark快速大数据分析》一书的笔记。","link":"/2021/08/23/spark-intro/"},{"title":"Leetcode上的SQL题（Part 2）","text":"题目601. Human Traffic of Stadium:Table: Stadium Column Name Type id int visit_date date people int visit_date is the primary key for this table.Each row of this table contains the visit date and visit id to the stadium with the number of people during the visit.No two rows will have the same visit_date, and as the id increases, the dates increase as well. Write an SQL query to display the records with three or more rows with consecutive id’s, and the number of people is greater than or equal to 100 for each. Return the result table ordered by visit_date in ascending order. Answer: 1234567891011select distinct a.*from stadium ajoin stadium bjoin stadium con (c.id-b.id=1 and b.id-a.id=1)or (a.id-b.id=1 and b.id-c.id=1)or (b.id-a.id=1 and b.id-c.id=2)where a.people&gt;=100and b.people&gt;=100and c.people&gt;=100order by a.id 或者 1234567891011121314151617select id,visit_date,peoplefrom(select id, visit_date, people ,count(*) over(partition by gp) as cntfrom(select *, id-flg as gpfrom(select *, dense_rank() over(order by id) as flgfrom stadiumwhere people&gt;=100) t1) t2) t3where cnt&gt;=3 Insights:后一种做法可以适用于任何连续时长 题目603. Consecutive Available Seats:Several friends at a cinema ticket office would like to reserve consecutive available seats.Can you help to query all the consecutive available seats order by the seat_id using the following cinema table? seat_id free 1 1 2 0 3 1 4 1 5 1 Your query should return the following result for the sample case above. seat_id 3 4 5 Note:The seat_id is an auto increment int, and free is bool (‘1’ means free, and ‘0’ means occupied.).Consecutive available seats are more than 2(inclusive) seats consecutively available.Answer: 1234567select c1.seat_idfrom cinema c1left join cinema c2on c1.seat_id+1=c2.seat_idleft join cinema c3on c1.seat_id-1=c3.seat_idwhere c1.free=1 and (c2.free=1 or c3.free=1) 或者 12345678910111213141516select seat_idfrom(select seat_id, count(*) over(partition by gp) as cntfrom(select * , seat_id-flg as gpfrom(select *, dense_rank() over(order by seat_id) as flgfrom cinemawhere free=1)t)t2)t3where cnt&gt;=2 Insights:后一种做法可以适用于任何连续时长 题目1127. User Purchase Platform:Table: Spending Column Name Type user_id int spend_date date platform enum amount int The table logs the spendings history of users that make purchases from an online shopping website which has a desktop and a mobile application.(user_id, spend_date, platform) is the primary key of this table.The platform column is an ENUM type of (‘desktop’, ‘mobile’).Write an SQL query to find the total number of users and the total amount spent using mobile only, desktop only and both mobile and desktop together for each date. The query result format is in the following example: Spending table: user_id spend_date platform amount 1 2019-07-01 mobile 100 1 2019-07-01 desktop 100 2 2019-07-01 mobile 100 2 2019-07-02 mobile 100 3 2019-07-01 desktop 100 3 2019-07-02 desktop 100 Result table: spend_date platform total_amount total_users 2019-07-01 desktop 100 1 2019-07-01 mobile 100 1 2019-07-01 both 200 1 2019-07-02 desktop 100 1 2019-07-02 mobile 100 1 2019-07-02 both 0 0 On 2019-07-01, user 1 purchased using both desktop and mobile, user 2 purchased using mobile only and user 3 purchased using desktop only.On 2019-07-02, user 2 purchased using mobile only, user 3 purchased using desktop only and no one purchased using both platforms. Answer: 123456789101112131415161718192021222324252627282930313233SELECT p.spend_date, p.platform, IFNULL(SUM(amount), 0) total_amount, COUNT(user_id) total_usersFROM( SELECT DISTINCT(spend_date), 'desktop' platform FROM Spending UNION SELECT DISTINCT(spend_date), 'mobile' platform FROM Spending UNION SELECT DISTINCT(spend_date), 'both' platform FROM Spending) pLEFT JOIN ( SELECT spend_date, user_id, IF(mobile_amount &gt; 0, IF(desktop_amount &gt; 0, 'both', 'mobile'), 'desktop') platform, (mobile_amount + desktop_amount) amount FROM ( SELECT spend_date, user_id, SUM(CASE platform WHEN 'mobile' THEN amount ELSE 0 END) mobile_amount, SUM(CASE platform WHEN 'desktop' THEN amount ELSE 0 END) desktop_amount### 将竖形数据改成横型数据 FROM Spending GROUP BY spend_date, user_id ) o) tON p.platform=t.platform AND p.spend_date=t.spend_dateGROUP BY spend_date, platform Insights: 用case when将竖向数据改成横向数据 两个union的subquery避免有因为数据为0而消失的行 题目597. Friend Request I: Overall Acceptance Rate:Table: FriendRequest Column Name Type sender_id int send_to_id int request_date date There is no primary key for this table, it may contain duplicates.This table contains the ID of the user who sent the request, the ID of the user who received the request, and the date of the request. Table: RequestAccepted Column Name Type requester_id int accepter_id int accept_date date There is no primary key for this table, it may contain duplicates.This table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted. Write an SQL query to find the overall acceptance rate of requests, which is the number of acceptance divided by the number of requests. Return the answer rounded to 2 decimals places. Note that:The accepted requests are not necessarily from the table friend_request. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate.It is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the ‘duplicated’ requests or acceptances are only counted once.If there are no requests at all, you should return 0.00 as the accept_rate. Follow up: Could you write a query to return the acceptance rate for every month? Could you write a query to return the cumulative acceptance rate for every day? Answer: 123selectround(ifnull((select count(distinct requester_id, accepter_id) from request_accepted)/(select count(distinct sender_id, send_to_id) from friend_request),0),2 )as accept_rate Follow-Up 1: 12345select if(d.req =0, 0.00, round(c.acp/d.req,2)) as accept_rate, c.month from(select count(distinct requester_id, accepter_id) as acp, Month(accept_date) as month from request_accepted) c,(select count(distinct sender_id, send_to_id) as req, Month(request_date) as month from friend_request) dwhere c.month = d.monthgroup by c.month Follow-Up 2: 12345678910111213141516171819202122## sum up the case when ind is 'a', which means it belongs to accept table, divided by sum of ind is 'r', which means it belong to request tableselect s.date1, ifnull(round(sum(case when t.ind = 'a' then t.cnt else 0 end)/sum(case when t.ind = 'r' then t.cnt else 0 end),2),0)from## get a table of all unique dates(select distinct x.request_date as date1 from friend_request x## The reason here use union sicne we don't want duplicate dateunion select distinct y.accept_date as date1 from request_accepted y) s## left join to make sure all dates are in the final outputleft join## get a table of all dates, count of each days, ind to indicate which table it comes from(select v.request_date as date1, count(*) as cnt,'r' as ind from friend_request v group by v.request_date## The reason here use union all sicne union all will be fasterunion allselect w.accept_date as date1, count(*) as cnt,'a' as ind from request_accepted w group by w.accept_date) t## s.date1 &gt;= t.date1, which for each reacord in s, it will join with all records earlier than it in ton s.date1 &gt;= t.date1# group by s.date1 then we can get a cumulative result to that daygroup by s.date1order by s.date1; Insights: distinct xx,xx IFNULL的用法 Cartesian product union all is faster than union 因为不需要去重 on后面接不等式 -&gt; 来计算cumulative -&gt; 效率较低 -&gt; 考虑用窗口函数代替 题目1083. Sales Analysis II:table: Product Column Name Type product_id int product_name varchar unit_price int — — product_id is the primary key of this table. Table: Sales Column Name Type seller_id int product_id int buyer_id int sale_date date quantity int price int This table has no primary key, it can have repeated rows.product_id is a foreign key to Product table. Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table. Answer: 1234567select buyer_idfrom Sales sjoin Product pon s.product_id=p.product_idgroup by buyer_idhaving sum(case product_name when \"S8\" then 1 else 0 end)&gt;0and sum(case product_name when \"iPhone\" then 1 else 0 end)=0 Insights: 题目1479. Sales by Day of the Week:Table: Orders Column Name Type order_id int customer_id int order_date date item_id varchar quantity int (ordered_id, item_id) is the primary key for this table.This table contains information of the orders placed.order_date is the date when item_id was ordered by the customer with id customer_id. Table: Items Column Name Type item_id varchar item_name varchar item_category varchar item_id is the primary key for this table.item_name is the name of the item.item_category is the category of the item. You are the business owner and would like to obtain a sales report for category items and day of the week. Write an SQL query to report how many units in each category have been ordered on each day of the week. Return the result table ordered by category. Answer: 12345678910111213select item_category as Category,ifnull(sum((case when weekday(order_date)=0 then 1 else 0 end)*quantity),0) as Monday,ifnull(sum((case when weekday(order_date)=1 then 1 else 0 end)*quantity),0) as Tuesday,ifnull(sum((case when weekday(order_date)=2 then 1 else 0 end)*quantity),0) as Wednesday,ifnull(sum((case when weekday(order_date)=3 then 1 else 0 end)*quantity),0) as Thursday,ifnull(sum((case when weekday(order_date)=4 then 1 else 0 end)*quantity),0) as Friday,ifnull(sum((case when weekday(order_date)=5 then 1 else 0 end)*quantity),0) as Saturday,ifnull(sum((case when weekday(order_date)=6 then 1 else 0 end)*quantity),0) as Sundayfrom Items ileft join Orders oon o.item_id=i.item_idgroup by Categoryorder by Category Insights:注意ifnull 题目1321. Restaurant Growth:Table: Customer Column Name Type customer_id int name varchar visited_on date amount int (customer_id, visited_on) is the primary key for this table.This table contains data about customer transactions in a restaurant.visited_on is the date on which the customer with ID (customer_id) have visited the restaurant.amount is the total paid by a customer. You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day). Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) . The query result format is in the following example: Return result table ordered by visited_on. average_amount should be rounded to 2 decimal places, all dates are in the format (‘YYYY-MM-DD’). Customer table: customer_id name visited_on amount 1 Jhon 2019-01-01 100 2 Daniel 2019-01-02 110 3 Jade 2019-01-03 120 4 Khaled 2019-01-04 130 5 Winston 2019-01-05 110 6 Elvis 2019-01-06 140 7 Anna 2019-01-07 150 8 Maria 2019-01-08 80 9 Jaze 2019-01-09 110 1 Jhon 2019-01-10 130 3 Jade 2019-01-10 150 Result table: visited_on amount average_amount 2019-01-07 860 122.86 2019-01-08 840 120 2019-01-09 840 120 2019-01-10 1000 142.86 1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.862nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 1203rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 1204th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86 Answer: 1234567select c1.visited_on, sum(c2.day_sum) as amount, round(avg(c2.day_sum),2) as average_amountfrom(select visited_on, sum(amount) as day_sum from Customer group by visited_on) c1,(select visited_on, sum(amount) as day_sum from Customer group by visited_on) c2where datediff(c1.visited_on,c2.visited_on) between 0 and 6group by c1.visited_onhaving count(c2.visited_on)=7 Insights: datadiff前一个参数比后一个参数在日期上更早 between 0 and 6 是大于等于0并小于等于6 因为这里要left join，所以必须先算出每日的sum，否则c1.visited_on可能会有不止七个c2.visit_on 题目1164. Product Price at a Given Date:Table: Products Column Name Type product_id int new_price int change_date date (product_id, change_date) is the primary key of this table.Each row of this table indicates that the price of some product was changed to a new price at some date. Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10. Answer: 12345678SELECT distinct a.product_id,ifnull(temp.new_price,10) as priceFROM products as aLEFT JOIN(SELECT *FROM productsWHERE (product_id, change_date) in (select product_id,max(change_date) from products where change_date&lt;=\"2019-08-16\" group by product_id)) as temp# 同时 in 两个columnon a.product_id = temp.product_id; 或者 1234567891011select t1.product_id, ifnull(new_price, 10) as pricefrom(select distinct product_id from Products) t1left join(select * from(select *, rank() over(partition by product_id order by change_date desc) as myrankfrom Products pwhere change_date &lt;= '2019-08-16')testwhere myrank=1)t2on t1.product_id=t2.product_id Insights: (xx,yy) in (zz,mm) 可以同时in多个变量 两种方法中的select distinct + left join都避免因为null而漏行 题目1135. Create a Seesion Bar Chart:Table: Sessions Column Name Type session_id int duration int session_id is the primary key for this table.duration is the time in seconds that a user has visited the application. You want to know how long a user visits your application. You decided to create bins of “[0-5&gt;”, “[5-10&gt;”, “[10-15&gt;” and “15 minutes or more” and count the number of sessions on it. Write an SQL query to report the (bin, total) in any order. The query result format is in the following example. Sessions table: session_id duration 1 30 2 199 3 299 4 580 5 1000 Result table: bin total [0-5&gt; 3 [5-10&gt; 1 [10-15&gt; 0 15 or more 1 For session_id 1, 2 and 3 have a duration greater or equal than 0 minutes and less than 5 minutes.For session_id 4 has a duration greater or equal than 5 minutes and less than 10 minutes.There are no session with a duration greater or equial than 10 minutes and less than 15 minutes.For session_id 5 has a duration greater or equal than 15 minutes.Answer: 1234SELECT '[0-5&gt;' AS bin, SUM(CASE WHEN duration &gt;= 0 AND duration &lt; 300 THEN 1 ELSE 0 END) AS total FROM Sessions UNIONSELECT '[5-10&gt;' AS bin, SUM(CASE WHEN duration &gt;= 300 AND duration &lt; 600 THEN 1 ELSE 0 END) AS total FROM Sessions UNIONSELECT '[10-15&gt;' AS bin, SUM(CASE WHEN duration &gt;= 600 AND duration &lt; 900 THEN 1 ELSE 0 END) AS total FROM Sessions UNIONSELECT '15 or more' AS bin, SUM(CASE WHEN duration &gt;= 900 THEN 1 ELSE 0 END) AS total FROM Sessions 或者 12345678910111213141516171819select T1.BIN,ifnull(total,0) as TOTAL from( SELECT \"[0-5&gt;\" AS BIN UNION SELECT \"[5-10&gt;\" AS BIN UNION SELECT \"[10-15&gt;\" AS BIN UNION SELECT \"15 or more\" AS BIN) T1left join(select (case when duration/60&lt;5 then \"[0-5&gt;\"when duration/60 &lt;10 then \"[5-10&gt;\"when duration/60 &lt;15 then \"[10-15&gt;\"else \"15 or more\" end) as bin,count(*) as totalfrom Sessionsgroup by bin) T2on T1.BIN=T2.bin Insights:case when … then … when … then … end 题目1517. Find Users With Valid E-mails:Table: Users Column Name Type user_id int name varchar mail varchar user_id is the primary key for this table.This table contains information of the users signed up in a website. Some e-mails are invalid. Write an SQL query to find the users who have valid emails. A valid e-mail has a prefix name and a domain where:The prefix name is a string that may contain letters (upper or lower case), digits, underscore ‘_’, period ‘.’ and/or dash ‘-‘. The prefix name must start with a letter.The domain is ‘@leetcode.com’.Return the result table in any order. The query result format is in the following example. Answer: 123select*from Userswhere mail REGEXP '^[a-zA-Z][a-zA-Z0-9_.-]+@leetcode.com' Insights: REGEXP ‘xxx’ 正则表达式 题目1454. Active Users:Table Accounts: Column Name Type id int name varchar the id is the primary key for this table.This table contains the account id and the user name of each account. Table Logins: Column Name Type id int login_date date There is no primary key for this table, it may contain duplicates.This table contains the account id of the user who logged in and the login date. A user may log in multiple times in the day. Write an SQL query to find the id and the name of active users. Active users are those who logged in to their accounts for 5 or more consecutive days. Return the result table ordered by the id.Answer: 1234567# select distinct l1.id, (select name from Accounts where id=l1.id) as name# from Logins l1# join Logins l2# on l1.id=l2.id# and datediff(l2.login_date,l1.login_date) between 1 and 4# group by l1.id,l1.login_date# having count(distinct l2.login_date)=4 或者 12345678910111213141516171819# Write your MySQL query statement belowselect id,login_datefrom(select *, count(*) over(partition by id,flg) as cntfrom(select id, name, login_date,date_sub(login_date, INTERVAL dt DAY) as flgfrom(select l.id, login_date, name, dense_rank() over(partition by l.id order by login_date) as dtfrom (select distinct * from Logins) lleft joinAccounts aon a.id=l.id)t1)t2)t3where cnt&gt;=5 或者 1234567891011121314select distinct id, namefrom(select id, count(1) as cnt, name, date_sub(login_date, INTERVAL dt DAY) as flgfrom(select l.id, login_date, name, dense_rank() over(partition by l.id order by login_date) as dtfrom (select distinct * from Logins) lleft joinAccounts aon a.id=l.id)t1group by id, date_sub(login_date, INTERVAL dt DAY))testwhere cnt&gt;=5 Insights:也是求连续时间的老套路了 连续时间问题 https://zhuanlan.zhihu.com/p/349358841 https://www.cnblogs.com/jiaxinwei/p/13936273.html https://blog.csdhttp://www.itongji.cn/detail?type=99993198n.net/ganghaodream/article/details/100083543 http://www.itongji.cn/detail?type=99993198","link":"/2021/08/25/leetcode-sql-2/"},{"title":"Leetcode上的SQL题（Part 3）","text":"题目619. Biggest Single Number:Table my_numbers contains many numbers in column num including duplicated ones.Can you write a SQL query to find the biggest number, which only appears once. num 8 8 3 3 1 4 5 6 For the sample data above, your query should return the following result: num 6 Note: If there is no such number, just output null. Answer: 12345678select max(num)from(select numfrom my_numbersgroup by numhaving count(*)=1)t 或者 12345678select (select numfrom my_numbersgroup by numhaving count(*)=1order by num desclimit 1) as num Insights:在方法二中，外面套一层select 会把[]变成[nulls] 题目1555. Bank Account Summary:Table: Users Column Name Type user_id int user_name varchar credit int user_id is the primary key for this table.Each row of this table contains the current credit information for each user. Table: Transactions Column Name Type trans_id int paid_by int paid_to int amount int transacted_on date trans_id is the primary key for this table.Each row of this table contains the information about the transaction in the bank.User with id (paid_by) transfer money to user with id (paid_to). Leetcode Bank (LCB) helps its coders in making virtual payments. Our bank records all transactions in the table Transaction, we want to find out the current balance of all users and check wheter they have breached their credit limit (If their current credit is less than 0). Write an SQL query to report. user_name credit, current balance after performing transactions. credit_limit_breached, check credit_limit (“Yes” or “No”) Return the result table in any order. The query result format is in the following example.Answer: 123456789101112131415select u.user_id, u.user_name, credit+ifnull(total,0) as credit,if(credit+ifnull(total,0)&gt;0,'No','Yes') as credit_limit_breachedfrom Users uleft join(select user_id, sum(amount) as totalfrom((select paid_by as user_id, -amount as amountfrom Transactions)union all(select paid_to as user_id, amountfrom Transactions) )agroup by user_id) bon u.user_id=b.user_id 或者 12345678select *,(case when CREDIT&gt;=0 then 'No' else 'Yes' end) as CREDIT_LIMIT_BREACHED from(select USER_ID, USER_NAME, credit+ifnull(sum(case when u.user_id=t1.paid_by then -amount else amount end),0) as CREDITfrom Users uleft join Transactions t1on u.user_id=t1.paid_by or u.user_id=t1.paid_togroup by user_id) test Insights:注意union all和union的区别 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。 排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。 题目608. Tree Node:Given a table tree, id is identifier of the tree node and p_id is its parent node’s id. id p_id 1 null 2 1 3 1 4 2 5 2 Each node in the tree can be one of three types:Leaf: if the node is a leaf node.Root: if the node is the root of the tree.Inner: If the node is neither a leaf node nor a root node. Write a query to print the node id and the type of the node. Sort your output by the node id. The result for the above sample is: id Type 1 Root 2 Inner 3 Leaf 4 Leaf 5 Leaf Answer: 1234567891011121314select distinct t1.id,(case when t3.id is null then 'Root'when t2.id is null then 'Leaf'else 'Inner' end) as Typefromtree t1left jointree t2on t2.p_id = t1.id # t2是t1的childleft jointree t3on t3.id = t1.p_id # t3是t1的parent Insights:Note the difference between isnull(expr,xxxx) and Is null and is not null 题目1285. Find the Start and End Number of Continious Ranges:Table: Logs Column Name Type log_id int id is the primary key for this table.Each row of this table contains the ID in a log Table. Since some IDs have been removed from Logs. Write an SQL query to find the start and end number of continuous ranges in table Logs. Order the result table by start_id. The query result format is in the following example: Logs table: log_id 1 2 3 7 8 10 Result table: start_id end_id 1 3 7 8 10 10 The result table should contain all ranges in table Logs.From 1 to 3 is contained in the table.From 4 to 6 is missing in the tableFrom 7 to 8 is contained in the table.Number 9 is missing in the table.Number 10 is contained in the table.Answer: 1234567select min(log_id) as start_id, max(log_id) as end_idfrom(select *, rank() over(order by log_id) as myrankfrom Logs) tgroup by log_id-myrank Insights: 题目1501. Countries You Can Safely Invest In:Table Person: Column Name Type id int name varchar phone_number varchar id is the primary key for this table.Each row of this table contains the name of a person and their phone number.Phone number will be in the form ‘xxx-yyyyyyy’ where xxx is the country code (3 characters) and yyyyyyy is the phone number (7 characters) where x and y are digits. Both can contain leading zeros. Table Country: Column Name Type name varchar country_code varchar country_code is the primary key for this table.Each row of this table contains the country name and its code. country_code will be in the form ‘xxx’ where x is digits. Table Calls: Column Name Type caller_id int callee_id int duration int There is no primary key for this table, it may contain duplicates.Each row of this table contains the caller id, callee id and the duration of the call in minutes. caller_id != callee_id A telecommunications company wants to invest in new countries. The company intends to invest in the countries where the average call duration of the calls in this country is strictly greater than the global average call duration. Write an SQL query to find the countries where this company can invest. Return the result table in any order.Answer: 12345678910111213141516elect c.name as countryfrom(select * fromCallsUNION ALLselect callee_id, caller_id, durationfromCalls) templeft join Person pon temp.caller_id=p.idleft join Country con substr(phone_number,1,3)=c.country_codegroup by c.namehaving avg(duration)&gt;(select avg(duration) from Calls) 或者使用CTE 123456789101112131415with CTE as(select * from Callsunion allselect callee_id, caller_id, durationfrom Calls)select c.name as countryfrom CTEleft join Person pon p.id=CTE.caller_idleft join Country con substring(p.phone_number,1,3)=c.country_codegroup by c.namehaving avg(duration)&gt;(select avg(duration) from Calls) 或者 12345678elect c.name as countryfrom Country cjoin Person pon substr(p.phone_number,1,3)=c.country_codejoin Calls caon p.id in (ca.caller_id,ca.callee_id)group by countryhaving avg(duration)&gt; (select avg(duration) from Calls) Insights:CTE只是一种retain罢了 题目1811. Find Interview CandidatesTable: Contests +————–+——+| Column Name | Type |+————–+——+| contest_id | int || gold_medal | int || silver_medal | int || bronze_medal | int |+————–+——+contest_id is the primary key for this table.This table contains the LeetCode contest ID and the user IDs of the gold, silver, and bronze medalists.It is guaranteed that any consecutive contests have consecutive IDs and that no ID is skipped. Table: Users +————-+———+| Column Name | Type |+————-+———+| user_id | int || mail | varchar || name | varchar |+————-+———+user_id is the primary key for this table.This table contains information about the users. Write an SQL query to report the name and the mail of all interview candidates. A user is an interview candidate if at least one of these two conditions is true: The user won any medal in three or more consecutive contests.The user won the gold medal in three or more different contests (not necessarily consecutive).Return the result table in any order.Answer: 123456789101112select name, mailfrom Contests c join Users u1on c.gold_medal=u1.user_idgroup by gold_medalhaving count(*)&gt;=3unionselect name,mailfrom Users u , Contests c1 , Contests c2, Contests c3where u.user_id in (c1.gold_medal, c1.silver_medal, c1.bronze_medal) and u.user_id in (c2.gold_medal, c2.silver_medal, c2.bronze_medal) and u.user_id in (c3.gold_medal, c3.silver_medal, c3.bronze_medal) and c1.contest_id-1 = c2.contest_id and c2.contest_id-1 = c3.contest_id Insights: union会自己去重 in的用法 题目569. Median Employee Salary Hard:The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary. Id Company Salary 1 A 2341 2 A 341 3 A 15 4 A 15314 5 A 451 6 A 513 7 B 15 8 B 13 9 B 1154 10 B 1345 11 B 1221 12 B 234 13 C 2345 14 C 2645 15 C 2645 16 C 2652 17 C 65 Write a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions. Id Company Salary 5 A 451 6 A 513 12 B 234 9 B 1154 14 C 2645 Answer: 123456789select Id, Company, Salaryfrom(select *,row_number() over(partition by Company order by Salary,id) as myasc,row_number() over(partition by Company order by Salary desc, id desc) as mydescfrom Employee e) testwhere myasc between mydesc-1 and mydesc+1order by Company,Salary Insights: 题目1777. Product’s Price For Each Store:Table: Products +————-+———+| Column Name | Type |+————-+———+| product_id | int || store | enum || price | int |+————-+———+(product_id,store) is the primary key for this table.store is an ENUM of type (‘store1’, ‘store2’, ‘store3’) where each represents the store this product is available at.price is the price of the product at this store. Write an SQL query to find the price of each product in each store. Return the result table in any order. The query result format is in the following example: Products table:+————-+——–+——-+| product_id | store | price |+————-+——–+——-+| 0 | store1 | 95 || 0 | store3 | 105 || 0 | store2 | 100 || 1 | store1 | 70 || 1 | store3 | 80 |+————-+——–+——-+Result table:+————-+——–+——–+——–+| product_id | store1 | store2 | store3 |+————-+——–+——–+——–+| 0 | 95 | 100 | 105 || 1 | 70 | null | 80 |+————-+——–+——–+——–+Product 0 price’s are 95 for store1, 100 for store2 and, 105 for store3.Product 1 price’s are 70 for store1, 80 for store3 and, it’s not sold in store2.Answer: 1234567select product_id,sum(case when store='store1' then price end) as store1,sum(case when store='store2' then price end) as store2,sum(case when store='store3' then price end) as store3from Products pgroup by product_id Insights: if no sum and keep group by: 那么只会留下每个product_id的第一行 if no sum and no group by：那么每个id会对应很多行 题目1613. Find the Missing IDs:Table: Customers +—————+———+| Column Name | Type |+—————+———+| customer_id | int || customer_name | varchar |+—————+———+customer_id is the primary key for this table.Each row of this table contains the name and the id customer. Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table. Notice that the maximum customer_id will not exceed 100. Return the result table ordered by ids in ascending order. The query result format is in the following example. Customers table:+————-+—————+| customer_id | customer_name |+————-+—————+| 1 | Alice || 4 | Bob || 5 | Charlie |+————-+—————+ Result table:+—–+| ids |+—–+| 2 || 3 |+—–+The maximum customer_id present in the table is 5, so in the range [1,5], IDs 2 and 3 are missing from the table.Answer: 123456WITH RECURSIVE seq AS ( SELECT 1 AS value UNION ALL SELECT value + 1 FROM seq WHERE value &lt; (select max(customer_id) from Customers) )select value as ids from seqwhere value not in(select customer_id from Customers) Insights:注意recursive的用法 题目1783. Grand Slam Titles:Table: Players Column Name Type player_id int player_name varchar — — player_id is the primary key for this table. Each row in this table contains the name and the ID of a tennis player. Table: Championships Column Name Type year int Wimbledon int Fr_open int US_open int Au_open int year is the primary key for this table.Each row of this table containts the IDs of the players who won one each tennis tournament of the grand slam. Write an SQL query to report the number of grand slam tournaments won by each player. Do not include the players who did not win any tournament. Return the result table in any order.Answer: 1234567891011SELECT *FROM (SELECTplayer_id,player_name,SUM( CASE WHEN player_id = Wimbledon THEN 1 ELSE 0 END + CASE WHEN player_id = Fr_open THEN 1 ELSE 0 END + CASE WHEN player_id = US_open THEN 1 ELSE 0 END + CASE WHEN player_id = Au_open THEN 1 ELSE 0 END ) AS grand_slams_countFROM Players CROSS JOIN Championships GROUP BY player_id, player_name ) TWHERE grand_slams_count &gt; 0 或者CTE 123456789101112131415 CTE: WITH CTE AS ( SELECT Wimbledon AS id FROM Championships UNION ALL SELECT Fr_open AS id FROM Championships UNION ALL SELECT US_open AS id FROM Championships UNION ALL SELECT Au_open AS id FROM Championships )SELECT player_id,player_name,COUNT(*) AS grand_slams_countFROM Players INNER JOIN CTE ON Players.player_id = CTE.idGROUP BY player_id, Insights:Cross Join = 直接中间放个逗号 = cartesian product 题目1107. New Users Daily Count:Table: Traffic +—————+———+| Column Name | Type |+—————+———+| user_id | int || activity | enum || activity_date | date |+—————+———+There is no primary key for this table, it may have duplicate rows.The activity column is an ENUM type of (‘login’, ‘logout’, ‘jobs’, ‘groups’, ‘homepage’). Write an SQL query that reports for every date within at most 90 days from today, the number of users that logged in for the first time on that date. Assume today is 2019-06-30. The query result format is in the following example: Traffic table:+———+———-+—————+| user_id | activity | activity_date |+———+———-+—————+| 1 | login | 2019-05-01 || 1 | homepage | 2019-05-01 || 1 | logout | 2019-05-01 || 2 | login | 2019-06-21 || 2 | logout | 2019-06-21 || 3 | login | 2019-01-01 || 3 | jobs | 2019-01-01 || 3 | logout | 2019-01-01 || 4 | login | 2019-06-21 || 4 | groups | 2019-06-21 || 4 | logout | 2019-06-21 || 5 | login | 2019-03-01 || 5 | logout | 2019-03-01 || 5 | login | 2019-06-21 || 5 | logout | 2019-06-21 |+———+———-+—————+ Result table:+————+————-+| login_date | user_count |+————+————-+| 2019-05-01 | 1 || 2019-06-21 | 2 |+————+————-+Note that we only care about dates with non zero user count.The user with id 5 first logged in on 2019-03-01 so he’s not counted on 2019-06-21.Answer: 123456789select login_date, count(1) user_countfrom(select user_id, min(activity_date) login_datefrom trafficwhere activity = 'login'group by user_id) awhere datediff('2019-06-30',login_date)&lt;=90group by login_date Insights: datadiff 后面的时间比前面的时间大 count(1) 和 count(*) 题目585. Investments in 2016:Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria: Have the same TIV_2015 value as one or more other policyholders.Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).Input Format:The insurance table is described as follows: Column Name Type PID INTEGER(11) TIV_2015 NUMERIC(15,2) TIV_2016 NUMERIC(15,2) LAT NUMERIC(5,2) LON NUMERIC(5,2) where PID is the policyholder’s policy ID, TIV_2015 is the total investment value in 2015, TIV_2016 is the total investment value in 2016, LAT is the latitude of the policy holder’s city, and LON is the longitude of the policy holder’s city. Sample Input PID TIV_2015 TIV_2016 LAT LON 1 10 5 10 10 2 20 20 20 20 3 10 30 20 20 4 10 40 40 40 Sample Output TIV_2016 45.00 Answer: 1234567891011121314151617181920212223SELECT SUM(insurance.TIV_2016) AS TIV_2016FROM insuranceWHERE insurance.TIV_2015 IN ( SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) &gt; 1 ) AND CONCAT(LAT, LON) IN ( SELECT CONCAT(LAT, LON) FROM insurance GROUP BY LAT , LON HAVING COUNT(*) = 1 ) Insights:","link":"/2021/08/26/leetcode-sql-3/"},{"title":"SQL调优和注意事项","text":"Reference：","link":"/2021/08/30/sql-improvement/"}],"tags":[{"name":"Tech","slug":"Tech","link":"/tags/Tech/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"文化","slug":"文化","link":"/tags/%E6%96%87%E5%8C%96/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"R","slug":"R","link":"/tags/R/"},{"name":"历史","slug":"历史","link":"/tags/%E5%8E%86%E5%8F%B2/"},{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"}],"categories":[]}