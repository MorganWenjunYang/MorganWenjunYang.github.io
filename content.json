{"pages":[],"posts":[{"title":"初学算法：动态规划、贪心和回溯问题","text":"以下是leetcode中，我觉得难度适中的几道动态规划、贪心和回溯问题，在这里记录下来，以供未来复习之用。 首先先过一下简要定义和区别。网络上有两篇很好的讲解： https://leetcode-cn.com/circle/article/yXFal5/ https://segmentfault.com/a/1190000022925306?utm_source=sf-similar-article EASY:53. Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: 123Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. logics: any subarray whose sum is positive is worth keeping. Let’s start with an empty array, and iterate through the input, adding numbers to our array as we go along. Whenever the sum of the array is negative, we know the entire array is not worth keeping, so we’ll reset it back to an empty array. Dynamic Programming12345678910111213class Solution(object): def maxSubArray(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" l=len(nums) max_cur_end=nums[0] max_tot=max_cur_end for i in range(1,l): max_cur_end=max(max_cur_end+nums[i],nums[i]) max_tot=max(max_cur_end,max_tot) return max_tot 70. Climbing StairsYou are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? DP with memorization 123456789101112131415class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n == 1: return 1 dp = [0] * (n+1) dp[0] = 1 dp[1] = 1 for i in range(2,n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] 斐波那契 1234567891011121314151617181920class Solution(object): def climbStairs(self, n): \"\"\" :type n: int :rtype: int \"\"\" if n == 1: return 1 elif n == 2: return 2 first = 1 second = 2 for i in range(3,n+1): third = first + second first, second = second, third return second 226. Invert Binary TreeGiven the root of a binary tree, invert the tree, and return its root. Recursion12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def invertTree(self, root): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" if not root: return None right = self.invertTree(root.right) left = self.invertTree(root.left) root.left = right root.right = left return root Medium740. Delete and EarnYou are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times: Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1. Return the maximum number of points you can earn by applying the above operation some number of times. Optimized Dynamic Programming123456789101112class Solution(object): def deleteAndEarn(self, nums): count = collections.Counter(nums) prev = None avoid = using = 0 for k in sorted(count): if k - 1 != prev: avoid, using = max(avoid, using), k * count[k] + max(avoid, using) else: avoid, using = max(avoid, using), k * count[k] + avoid prev = k return max(avoid, using) 198. House Robber (similar to Q740)You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Dynamic Programming 123456789101112131415161718192021class Solution: def rob(self, nums: List[int]) -&gt; int: # Special handling for empty case. if not nums: return 0 maxRobbedAmount = [None for _ in range(len(nums) + 1)] N = len(nums) # Base case initialization. maxRobbedAmount[N], maxRobbedAmount[N - 1] = 0, nums[N - 1] # DP table calculations. for i in range(N - 2, -1, -1): # Same as recursive solution. maxRobbedAmount[i] = max(maxRobbedAmount[i + 1], maxRobbedAmount[i + 2] + nums[i]) return maxRobbedAmount[0] Optimized Dynamice Programming 123456789101112131415161718192021222324class Solution: def rob(self, nums: List[int]) -&gt; int: # Special handling for empty case. if not nums: return 0 N = len(nums) rob_next_plus_one = 0 rob_next = nums[N - 1] # DP table calculations. for i in range(N - 2, -1, -1): # Same as recursive solution. current = max(rob_next, rob_next_plus_one + nums[i]) # Update the variables rob_next_plus_one = rob_next rob_next = current return rob_next 39. Combination SumGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Backtracking: can be unfolded as DFS12345678910111213141516171819202122232425class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: results = [] def backtrack(remain, comb, start): if remain == 0: # make a deep copy of the current combination results.append(list(comb)) return elif remain &lt; 0: # exceed the scope, stop exploration. return for i in range(start, len(candidates)): # add the number into the combination comb.append(candidates[i]) # give the current number another chance, rather than moving on backtrack(remain - candidates[i], comb, i) # backtrack, remove the number from the combination comb.pop() backtrack(target, [], 0) return results 343. Integer BreakGiven an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers. Return the maximum product you can get. Dynamic Programming123456789101112131415161718192021222324252627282930313233Integer BreakDPclass Solution: def integerBreak(self, n: int) -&gt; int: # n=2 2=1+1 1*1=1 # n=3 3=2+1 2*1=2 # n=4 4=2+2 2*2=4 # n=5 5=3*2 2*3=6 # n=6 6=3+3 3*3=9 # n=7 7=2+2+3/4+3 2*2*3=4*3=12 # n=8 8=3+3+2 3*3*2=18 # n=9 9=3+3+3 3*3*3=27 # n=10 10=3+3+2+2 3*3*4=36 # n=11 11=3+3+3+2/3+3+3+2 54 if n==2: return 1 if n==3: return 2 if n==4: return 4 if n==5: return 6 if n==6: return 9 cand=[0]*(n+1) cand[2]=1 cand[3]=2 cand[4]=4 cand[5]=6 cand[6]=9 for i in range(7,n+1): cand[i]=max(3*cand[i-3],2*cand[i-2]) return cand[n] 322. Coin ChangeYou are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. 17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. picture: see https://leetcode.com/problems/letter-combinations-of-a-phone-number/ or as summarized below 12letters = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"} Backtracking123456789101112131415161718192021222324252627282930class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: if len(digits) == 0: return [] out = [] # Map all the digits to their corresponding letters letters = {\"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"} def BT(index, path): if len(path) == len(digits): out.append(''.join(path)) return # Get the letters that the current digit maps to, and loop through them possible_letters = letters[digits[index]] for letter in possible_letters: # Add the letter to our current path path.append(letter) # Move on to the next digit BT(index + 1, path) # Backtrack by removing the letter before moving onto the next path.pop() # Initiate backtracking with an empty path and starting index of 0 BT(0, []) return out 91. Decode Ways (similar to climbing stairs)A message containing letters from A-Z can be encoded into numbers using the following mapping: 1234'A' -&gt; \"1\"'B' -&gt; \"2\"...'Z' -&gt; \"26\" To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into: “AAJF” with the grouping (1 1 10 6) “KJF” with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”. Given a string s containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer. Dynamic Programming1234567891011121314151617181920212223class Solution: def numDecodings(self, s: str) -&gt; int: # Array to store the subproblem results dp = [0 for _ in range(len(s) + 1)] dp[0] = 1 # Ways to decode a string of size 1 is 1. Unless the string is '0'. # '0' doesn't have a single digit decode. dp[1] = 0 if s[0] == '0' else 1 for i in range(2, len(dp)): # Check if successful single digit decode is possible. if s[i - 1] != '0': dp[i] = dp[i - 1] # Check if successful two digit decode is possible. two_digit = int(s[i - 2 : i]) if two_digit &gt;= 10 and two_digit &lt;= 26: dp[i] += dp[i - 2] return dp[len(s)] 46. PermutationGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: 12Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Backtracking: https://leetcode.com/problems/permutations/solution/123456789101112131415161718192021222324class Solution: def permute(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" def backtrack(first = 0): # if all integers are used up if first == n: output.append(nums[:]) for i in range(first, n): # place i-th integer first # in the current permutation nums[first], nums[i] = nums[i], nums[first] # use next integers to complete the permutations backtrack(first + 1) # backtrack nums[first], nums[i] = nums[i], nums[first] n = len(nums) output = [] backtrack() return output 718. Maximum Length of Repeated SubarrayGiven two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays. Example 1:123Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3,2,1]. Dynamic ProgrammingSince a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know dp[i][j] = dp[i+1][j+1] + 1. Also, the answer is max(dp[i][j]) over all i, j. We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in dp for any larger i, j. 12345678class Solution(object): def findLength(self, A, B): memo = [[0] * (len(B) + 1) for _ in range(len(A) + 1)] for i in range(len(A) - 1, -1, -1): for j in range(len(B) - 1, -1, -1): if A[i] == B[j]: memo[i][j] = memo[i + 1][j + 1] + 1 return max(max(row) for row in memo)","link":"/2021/07/26/DP/"},{"title":"印度神话梳理与印度起源的宗教们","text":"印度神话对于小时候只看过中国神话、希腊罗马神话的我，可谓是一个极其新鲜的话题，只可惜年龄导致的记忆力衰退让我即使看了三遍书，也还是不能记得大概。所以写一个关于印度神话的memo，对于我掌握印度神话的脉络还是非常有必要的。篇幅不宜过长，否则也不利于经常复习。 本篇主要包含以下几个部分： 摩诃婆罗多 ~ 薄伽梵歌 罗摩衍那 沙恭达罗 宗教与民族","link":"/2021/05/19/India/"},{"title":"音乐随感","text":"瞎说，胡说，想到什么说什么，勿认真 Aaliyah Age Ain’t Nothing But A Number Alicia Keys The Diary of Alicia Keys As I Am Aimer After Dark Amy Winehouse Frank Annie Lennox Medusa Beyonce Dangerously in Love Black Box Recorder The Facts Of Life Passionoia Buika Nina de Fuego Carol King Tapestry Erykah Badu Live Mama’s Gun Father John Misty Pure Comedy God’s Favorite Customer Flower 花时计 Florence &amp; The Machine Ceremonials How Big, How Blue, How Beautiful Fugees The Score H.E.R H.E.R I Used To Know Her The Internet Ego Death Hive Mind Jill Scott Who Is Jill Scott Karyn White Karyn White Lady Gaga Artpop Joanne Lana Del Rey Born to Die Ultraviolence Honeymoon Lust For Life Norman Fucking Rockwell Lauryn Hill The Miseducation of Luaryn Hill Lykki Li I Never Learn Marina And The Diamond Electra Heart Mary J Mlige The Breakthrough MO No Mythologies To Follow When I Was Young Forever Neverlend Sade Diamond Life SWV It’s About Time SZA Ctrl Z Tinashe Aquarius Reverie Black Water TLC Crazysexycool Toni Braxton Secrets VanJess Homegrown Silk Canvas 柴田淳 COVER 70’s 幸田来未 Trick 一青窈 月天心 元ちとせ カッシーニ 椎名林檎 無罪モラトリアム 平成風俗 混搭专/Soundtrack Waiting To Exhale The Witcher 3 银翼杀手","link":"/2021/07/26/Music-general/"},{"title":"你老婆变成了怪物？真巧，我的也是","text":"","link":"/2021/05/18/Monster-Wife/"},{"title":"R Markdown 模板自动生成文件","text":"","link":"/2021/05/20/RMD-generate-document/"},{"title":"用Docker部署Flask到阿里云","text":"可能是最简单的部署方式。 当在flask里使用app.run（）的时候在运行flask的时候，我们只是将app部署到了一个测试环境，而真正将我们的app分享给更多人使用，需要经过更多的步骤。 首先简单讲一下我对docker的理解（完全不一定准确）。dockerhub就如同GitHub一样，是一个托管平台，不同点在于github托管的是代码，dockerhub托管的则是镜像。Github的代码clone到本地后并不能直接使用，比如当在代码中import numpy as np或者library(tidyr)，而你的环境中并没有这个包时，显然这些代码并不能一下子顺利的运行，你需要先下载所有依赖的包，另外也可能存在潜在的路径问题。对于docker来说，它所保存的不仅是代码，而是将整个代码和它运行的环境打包成一个镜像，用户下载镜像，得到的就是一个独立自洽的小宇宙（其实是小宇宙模板，我们之后再说），可以不经任何处理，直接使用。 与镜像-image紧密相连的一个概念是容器-container。 镜像只是一个模板，从这个模板我们可以创造出很多容器，每个容器内部都是一样的环境，运行一样的程序。也就是说，只要每个用户都将同样的镜像下载到本地，并在此之上运行容器，那么我们就可以保证所有用户都在一样的环境下运行一样的程序。 来详细看一下实际操作。 下载Gunicorn和Gevent两个包：1pip install gunicorn gevent 在应用目录为gunicorn建立配置文件，/gunicorn.conf.py，内容如下：123workers = 5 # 定义同时开启的处理请求的进程数量，根据网站流量适当调整worker_class = \"gevent\" # 采用gevent库，支持异步处理请求，提高吞吐量bind = \"0.0.0.0:80\" 可以使用gunicorn命令来测试是否可以正确运行，命令如下，打开网址127.0.0.1:80，将会打开我们的网站。1gunicorn start:app -c gunicorn.conf.py 下载linux cmd对于win系统来说，首先需要下载windows terminal和ubuntu，这样我们就可以在win系统上使用linux cmd。请follow如下链接，在ubuntu中下载dockerUbuntu Docker 安装 创建requirements文件为该应用创建一个 requirements.txt 文件，以便容器里面 python 环境的安装：/requirements.txt。e.g. 如果你的项目用到了flask，numpy，pandas，那该文件就会像这样1234flasknumpypandas...... 建立Dockerfile在真正把我们的app封装成镜像之前，还需要在应用目录建立Dockerfile文档（注意，这个文件不是txt，是一个没有扩展名的文件）。Dockerfile的内容包括复制文件到容器内路径，需要在容器内命令行run的指令等。Dockerfile的细节请参考如何编写dockerfile一个简单的例子如下：123456789FROM python:3.6WORKDIR /Project/demoCOPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .CMD [\"gunicorn\", \"start:app\", \"-c\", \"./gunicorn.conf.py\"] 其中，第二行 WORKDIR 后面写的是要部署到服务器上的路径，最后一行里面的 start 是我们上面写的 python 启动文件名，app 是启动文件里面要启动的应用名（变量名）也就是说在这个例子里，你的flask主程序/启动程序应该叫做start.py，在这个py文件中，你定义的flask app名字叫做app。当容器运行时，它会自动地下载requirements文件中指定的包，复制所有文件到容器根目录，并在容器cmd中按照配置文件上线flask程序。 生成镜像在linux cmd中进入到flask项目的目录，输入1sudo docker build -t 'nameOfYourImage' 回车执行后，输入sudo docker images，可以看到新生成的镜像 上传至镜像托管平台（以dockerhub为例）dockerhub是一个镜像托管平台，和github一样，如果你要在另一台电脑使用代码，你需要执行一个上传下拉的操作。（当然你也可以使用其他镜像托管平台）首先注册dockerhub账号，免费用户将只能拥有一个repository，也就是只能存储一个镜像（和它的不同版本）。这时候继续回到本地linux cmd，我们需要在本地使用docker login登录dockerhub，成功登陆后，将我们之前建立的镜像根据dockerhub的账户名和repository名重命名，并打上tag。1docker tag previousImageID(SHA) yourAccountName/youRepoName:Tagname 接下来使用，像github一样，使用docker push yourAccountName/youRepoName:Tagname将我们的镜像push到dockerhub。 在服务器下载docker，下拉镜像并运行容器不管是centOS，aliyun linux还是ubuntu，在你的服务器上下载docker，对于aliyun linux来说可能是podman。但不论如何，你需要一个镜像管理工具。以下以podman为例：用podman pull yourAccountName/youRepoName:Tagname从dockerhub拉取镜像到本地接下来用如下代码，基于镜像建立容器，并让容器运行起来，上线我们的flask app：1podman run -d -p 80:80 --name imageName(or SHA) containerName 此时输入podman ps，可以看到我们的容器正在运行。注意 -p 80:80 说明我们把容器的80端口映射到服务器的80端口。还记得我们在第一步创建的配置文件将我们的程序绑定到80端口，所以这里我们需要把容器的80端口映射出去，我们才能够在外部访问它，这个服务器端口不一定是80，可以是任何你希望的端口，但注意要在设置服务器时把这个端口开放给外部使用。 That’s it! Have fun with docker! 参考网址： Flask + Docker 无脑部署新手教程 docker-image container 基本操作 -常用命令 网络调试指令ping、telnet、curl docker系列学习（二）：Docker + Flask 例子 （全系列值得一看） easybook: Docker 从入门到实践 Why Does My Docker Container Stop? Container exit code dockerfile——EXPOSE和端口映射参数-p、-P总结 如何编写dockerfile 如何上传镜像到dockerhub cron测试器 cron范例 vim指南 Linux定时运行Python脚本 从本地发送文件到云服务器–ECS云助手","link":"/2021/08/06/flask-docker/"},{"title":"Hexo+Github 超简易个人博客搭建","text":"","link":"/2021/05/19/Tech-Hexo/"},{"title":"Leetcode上的SQL题（Part 1）","text":"本篇整理Leetcode SQL当中比较有代表性、比较易错的某些题目，以供未来学习、复习之用。 题目1179. Reformat Department Table:Table: Department Column Name Type id int revenue int month varchar (id, month) is the primary key of this table.The table has information about the revenue of each department per month.The month has values in [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”]. Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month. Answer: 1234567891011121314151617selectid,sum(case when month='jan' then revenue else null end) as Jan_Revenue,sum(case when month = 'feb' then revenue else null end) as Feb_Revenue,sum(case when month = 'mar' then revenue else null end) as Mar_Revenue,sum(case when month = 'apr' then revenue else null end) as Apr_Revenue,sum(case when month = 'may' then revenue else null end) as May_Revenue,sum(case when month = 'jun' then revenue else null end) as Jun_Revenue,sum(case when month = 'jul' then revenue else null end) as Jul_Revenue,sum(case when month = 'aug' then revenue else null end) as Aug_Revenue,sum(case when month = 'sep' then revenue else null end) as Sep_Revenue,sum(case when month = 'oct' then revenue else null end) as Oct_Revenue,sum(case when month = 'nov' then revenue else null end) as Nov_Revenue,sum(case when month = 'dec' then revenue else null end) as Dec_Revenuefrom departmentgroup by idorder by id Insights:用case when … then … else … end 避免使用多个select来建立多个新的column 题目180. Consecutive Numbers:Table: Logs Column Name Type id int num varchar id is the primary key for this table.Write an SQL query to find all numbers that appear at least three times consecutively.Return the result table in any order. Answer: 12345678910selectdistinct l1.num as ConsecutiveNumsfromLogs l1,Logs l2,Logs l3where l1.id = l2.id - 1and l2.id = l3.id - 1and l1.num = l2.numand l2.num = l3.num Insights:连续天数/连续数字问题可以先做Cartesian Product，然后再用where筛选符合条件的记录。但是这样的话，空间上是否占用过多？ 题目196. Delete Duplicate Emails:Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. Id Email 1 john@example.com 2 bob@example.com 3 john@example.com Id is the primary key column for this table.For example, after running your query, the above Person table should have the following rows: Id Email 1 john@example.com 2 bob@example.com Your output is the whole Person table after executing your sql. Use delete statement. Answer: 123456789delete from Personwhere Id in(select Id from( select Id, rank() over(partition by Email order by Id) as myrank from Person)as twhere myrank&gt;=2) Insights:Delete from … where … 题目1132. Reported Posts II:Table: Actions Column Name Type user_id int post_id int action_date date action enum extra varchar There is no primary key for this table, it may have duplicate rows.The action column is an ENUM type of (‘view’, ‘like’, ‘reaction’, ‘comment’, ‘report’, ‘share’).The extra column has optional information about the action such as a reason for report or a type of reaction. Table: Removals Column Name Type post_id int remove_date date post_id is the primary key of this table.Each row in this table indicates that some post was removed as a result of being reported or as a result of an admin review. Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places. Answer: 123456789101112select round(avg(rm/all_rp)*100,2) as average_daily_percentfrom(selectcount(distinct a.post_id) as all_rp,count(distinct r.post_id) as rmfrom Actions aleft join Removals ron a.post_id = r.post_idwhere action='report' and extra = 'spam'group by action_date)t Insights:注意left join而不是join，避免不在actions内的记录被count计算到 题目1355. Activity Participants:Table: Friends Column Name Type id int name varchar activity varchar id is the id of the friend and primary key for this table.name is the name of the friend.activity is the name of the activity which the friend takes part in. Table: Activities Column Name Type id int name varchar id is the primary key for this table.name is the name of the activity. Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants. Return the result table in any order. Each activity in table Activities is performed by any person in the table Friends. Answer: 12345select activityfrom friendsgroup by activityhaving count(*)&gt; (select count(*) from friends group by activity order by 1 limit 1)and count(*)&lt; (select count(*) from friends group by activity order by 1 desc limit 1) 或者 123456SELECT activityFROM (SELECT activity, DENSE_RANK () OVER (ORDER BY COUNT(*) DESC) RK, DENSE_RANK () OVER (ORDER BY COUNT(*)) RK2FROM FriendsGROUP BY 1) TEMPWHERE rk != 1 and rk2 !=1 Insights: nested query 的使用的区别 不是题干给出的每张表都有用 双向窗口函数 dense_rank与rank的区别 题目602. Friends Requests II: Who has the most friends:In social network like Facebook or Twitter, people send friend requests and accept others’ requests as well. Table request_accepted requester_id accepter_id accept_date 1 2 2016_06-03 1 3 2016-06-08 2 3 2016-06-08 3 4 2016-06-09 This table holds the data of friend acceptance, while requester_id and accepter_id both are the id of a person. Write a query to find the the people who has most friends and the most friends number under the following rules: It is guaranteed there is only 1 people having the most friends.The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value.For the sample data above, the result is: Result table: id num 3 3 The person with id ‘3’ is a friend of people ‘1’, ‘2’ and ‘4’, so he has 3 friends in total, which is the most number than any others.Follow-up:In the real world, multiple people could have the same most number of friends, can you find all these people in this case? Answer: 1234567891011121314select requester_id as id, count(*) as numfrom(select requester_id, accepter_idfromrequest_accepted r1unionselect accepter_id, requester_idfromrequest_accepted r2)tgroup by requester_idorder by num desclimit 1 Insights:union all: keep all the duplicate entryunion: only keep the distinct ones 题目1327. List the Products Ordered in a Period:Table: Products Column Name Type product_id int product_name varchar product_category varchar product_id is the primary key for this table.This table contains data about the company’s products. Table: Orders Column Name Type product_id int order_date date unit int There is no primary key for this table. It may have duplicate rows.product_id is a foreign key to Products table.unit is the number of products ordered in order_date. Write an SQL query to get the names of products with greater than or equal to 100 units ordered in February 2020 and their amount.Return result table in any order. Answer: 1234567select product_name, sum(unit) as unitfrom Orders oleft join Products po.product_id = p.product_idwhere order_date between '2020-02-01' and '2020-02-29'group by product_namehaving unit &gt;= 100 Insights:between是两边包含的一个关系表达式 题目1398. Customers Who Bought Product A and B but Not C:Table: Customers Column Name Type customer_id int customer_name varchar customer_id is the primary key for this table.customer_name is the name of the customer. Table: Orders Column Name Type order_id int customer_id int product_name varchar order_id is the primary key for this table.customer_id is the id of the customer who bought the product “product_name”. Write an SQL query to report the customer_id and customer_name of customers who bought products “A”, “B” but did not buy the product “C” since we want to recommend them buy this product. Return the result table ordered by customer_id. Answer: 1234567891011select * from Customerswhere customer_id in(select distinct customer_id from Orderswhere product_name=\"A\")andcustomer_id in(select distinct customer_id from Orderswhere product_name=\"B\")and customer_id not in(select distinct customer_id from Orderswhere product_name=\"C\") Insights:nested query 题目1045. Customers Who Bought All Products:Table: Customer Column Name Type customer_id int product_key int product_key is a foreign key to Product table. Table: Product Column Name Type product_key int product_key is the primary key column for this table. Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table. Return the result table in any order. Answer: 1234select customer_idfrom Customer cgroup by customer_idhaving count(distinct product_key) = (select count(*) from Product) Insights:做题时要注意distinct是否会影响count的结果，并根据实际情况决定加或者不加 题目262. Trips and Users:Table: Trips Column Name Type Id int Client_Id int Driver_Id int City_Id int Status enum Request_at date Id is the primary key for this table.The table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are foreign keys to the Users_Id at the Users table.Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’). Table: Users Column Name Type Users_Id int Banned enum Role enum Users_Id is the primary key for this table.The table holds all users. Each user has a unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).Status is an ENUM type of (‘Yes’, ‘No’). Write a SQL query to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between “2013-10-01” and “2013-10-03”. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day. Return the result table in any order. Round Cancellation Rate to two decimal points. Answer: 123456789select Request_at as Day,round(sum(case when Status = 'cancelled_by_driver' or Status = 'cancelled_by_client' then 1 else 0 end)/count(*),2) as 'Cancellation Rate'from Trips twhere Client_Id not in (select Users_Id from Users where Banned='Yes')and Driver_Id not in (select Users_Id from Users where Banned='Yes')and Request_at between '2013-10-01' and '2013-10-03'group by Request_at Insights:when Status = ‘cancelled_by_driver’ or Status = ‘cancelled_by_client’也可以写成 Status in (“cancelled_by_driver”,”cancelled_by_client”) 题目615. Average Salary: Departments VS Company:Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company’s average salary. Table: salary id employee_id amount pay_date 1 1 9000 2017-03-31 2 2 6000 2017-03-31 3 3 10000 2017-03-31 4 1 7000 2017-02-28 5 2 6000 2017-02-28 6 3 8000 2017-02-28 The employee_id column refers to the employee_id in the following table employee. employee_id department_id 1 1 2 2 3 2 So for the sample data above, the result is: pay_month department_id comparison 2017-03 1 higher 2017-03 2 lower 2017-02 1 same 2017-02 2 same Answer: 12345678910111213select distinct date_format(pay_date, '%Y-%m') as pay_month,department_id,(case when dept_avg&lt; company_avg then \"lower\" when dept_avg&gt; company_avg then \"higher\" else \"same\" end) as comparisonfrom(select s.employee_id, e.department_id,pay_date,amount, avg(amount) over (partition by pay_date) as company_avg , avg(amount) over (partition by pay_date, department_id) as dept_avgfrom salary as sjoin employee as eon s.employee_id=e.employee_id) as tmp Insights: case when … then … when … then … else … data_format() 改变日期格式，这里也可以使用substr(pay_data,1,7) 活用窗口函数，本体为聚合函数的窗口函数 窗口函数 窗口函数语法 12&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;) &lt;窗口函数&gt;的位置，可以放以下两种函数： 1） 专用窗口函数，比如rank, dense_rank, row_number等 2） 聚合函数，如sum. avg, count, max, min等 窗口函数有以下功能： 1）同时具有分组（partition by）和排序（order by）的功能 2）不减少原表的行数，所以经常用来在每组内排名 注意事项 窗口函数原则上只能写在select子句中 窗口函数使用场景 1）业务需求“在每组内排名”，比如： 排名问题：每个部门按业绩来排名 topN问题：找出每个部门排名前N的员工进行奖励","link":"/2021/07/26/leetcode-sql/"},{"title":"公主们的战国","text":"织田信长、丰臣秀吉、德川家康，日本战国历史无法绕开的三个人。东亚历史往往是男人戏，女人永远在暗处。而日本战国也正有这样一条女性的暗线，串起三位豪杰领衔主演的乱世风云。 故事从年纪最长的织田信长说起。织田家族是尾张地方的豪强，家族以美貌闻名，男帅女美。信长本人年轻时是有名的不正经帅哥，而妹妹阿市也是名动天下的美女。古代的贵族女性的普遍经历-政治婚姻，使得市姬与近江豪强浅井家族的浅井长政成婚。浅井长政是一个相对的好人，两人非常恩爱，诞生了三个女儿和另外的两个男孩。 说到这里，大家也应该都明白了，这三个女孩就是这个故事的主角。迎接她们的是波澜四起的人生。 三个女孩，长女茶茶，次女初，小女江，生长在一个有爱的家庭当中，度过了相当不错的童年。 当然，乱世之所以是乱世，正因为一个人身处乱世就算什么错也不犯，麻烦也会自己找上门来。我们略去其中波折，只要知道浅井长政或为利，或为名，或为荣誉，加入了信长的敌对阵营，最终不敌当时还姓羽柴的丰臣秀吉，不得已在居城小谷城与父亲一同切腹自尽，留下儿女妻子给妻兄信长。长男被处刑，次男出遁，三个女孩和阿市却得以在织田家继续生活。 传言道，市姬的美貌得到了织田家大老新贵们的垂涎，其中就有家老代表柴田胜家与新贵代表羽柴秀吉，两人都对市姬抱有极大的兴趣。但信长最终选择了胜家作为市姬的下一个结婚对象和拉拢对象。 战国时代最著名的诗，莫过于织田信长在本能寺的绝命诗： 思えば此の世は常の住処にあらず草の葉におく白露水に宿る月より猶あやし金谷に花を詠じ栄華はさきを立って無常の風にさそわるる南楼の月を弄ぶ輩も月に先だって有為の雲に隠れり人間五十年下天の中をくらぶれば夢幻のごとくなり一度生を受け滅せぬ者のあるべきか滅せぬ者のあるべきか是を菩提の種と思ひ定めざらんは口惜しかりし次第ぞと思ひ定め急ぎ都へ上りつつ敦盛の御首を見れば物憂さに獄門よりも盗み取り我が宿に帰り御僧を供養し無常の煙となし申し 中译如下： 常思人世漂流无常譬如朝露水中映月刹那繁华瞬间即逝风流人物今非昔比人生五十年莫非熙熙攘攘浮生幻梦名垂青史功败湮灭只是宿命因果一念之间有何可惜急至京都忧心难忍狱门示众敦盛之首窃而归家传僧供奉叹息如烟人间无常 死亡是有其美感的。不管英雄或枭雄，一个善终或是在某地郁郁而终，总是觉得和他们波澜壮阔的一生不太相配，而命运却慷慨给信长的人生一个足够戏剧的结尾。本能寺之变一直是很多影视剧、文学作品常常涉及的故事。枭雄，叛徒，刀剑，火光，壮士殒命，无一不是充满戏剧性冲突性的元素，在吞噬一切的火光中结束璀璨的一生，不失为配得上枭雄的结局。 在信长死后，织田家的势力陷入了分崩离析，这一次，柴田胜家与羽柴秀吉走到了对立面，而秀吉又一次获得了胜利。柴田胜家和市姬在天守阁自杀身亡，将三个女孩托付给秀吉，并告诉他，这是先主君信长的外甥女，希望他好好照顾。于是，三姐妹又一次改换门庭，寄人篱下，成为秀吉的养女。 逐个击败政敌后，秀吉的权力来到了巅峰，信长不曾做到的关白、太政大臣，他一一收归己有。也许是我的刻板印象吧，当一个男人拥有了所有，他对没有征服的人/事的渴望就会达到顶峰。传闻市姬的长女茶茶和她十分相似，这似乎可以解释秀吉染指茶茶的原因，又或者茶茶也只不过是他征服的一个个高门贵女之一。总而言之，茶茶成为了秀吉的侧室，号为淀殿，说到这里，不得不说秀吉也是惯犯了，之前的另一位养女——好兄弟前田利家之女也被他收作了侧室。茶茶与其他人的不同除了肖似市姬之外，最重要的是她给秀吉带来了继承人。秀吉曾有一子名秀胜，但不幸夭折，过后多年毫无子息，秀吉因而将外甥三好秀次收为养子。在秀吉五十二岁时，淀殿/茶茶生下了儿子鹤松，秀吉为其取小名为‘舍’，以期用一个贱命为孩子消灾解难，而不幸的是鹤松三岁便夭折了。这个孩子的降生让秀吉本已属意秀次，决定好好培养秀次的心又动摇了。四年后，淀殿又生下了秀赖。这一次，丰臣政权的矛盾开始真正显露出来。 这里想要推荐一部日本历史小说——《丰臣家的人们》，本书出自历史小说大师司马辽太郎之手，书中以丰臣秀吉身边的几个人为主题，从不同人的不同命运轨迹，描绘了丰臣政权的兴衰。其中下场最悲惨，人生起落之大，要数秀吉的外甥秀次了。秀次本就是中人之姿，如果时代没有造就他的叔父，他也许就可以做一个普通的农家子弟，在乱世之中过尽可能普通的生活。然而，命运让他做了名家三好家的继承人，又继而成为丰臣家族的继承人，就注定了秀次这一生不可能平静的度过。正如名言所说，“命运给予的礼物早在暗中标好了价格”，而秀次的礼物需要用性命来偿还。 可以想见，当秀吉的亲生儿子出生，秀吉又身体康健，秀次作为丰臣家族继承人的身份是岌岌可危的。最后处决了关白秀次一家所有人","link":"/2021/05/20/himesama/"},{"title":"百合文学影视的机锋","text":"要探讨百合文学影视，可以出发的角度不可谓不多，而本文主要想聊聊以下几个方面： 爱情的障碍 男性角色的刻画 情色场面的描绘 说起百合影视，网络上讨论度、风评较好的作品不得不提燃烧女子的肖像、卡罗尔、小姐/指匠琴挑这四部。这四部作品各有所长，都有让人难忘的优秀画面和剧情。 简单总括一下我对四部片子的感受。 燃烧女子的肖像打造了一个纯粹女性、没有任何男性的孤岛，当片尾取画的男子出现时，正是这个伊甸园被打破的时刻。不知道是不是女性角色多以及女导演拍摄或是我身为女性带来的一种特质，我总能在画面中，觉察到情绪的流动，眼神、嘴角、眉梢，情绪一点一点流露出来。真正动人的不是大声说出的爱，而是隐藏在平静外表下涌动的感情，克制方才更加性感，过于直白反倒到人胃口。 我特别喜欢两位主角一站一坐对于主体客体的一番讨论，也许正是这种画画设定带来的安静的审视，让她们即使没有很多的接触，也能格外的了解彼此。当然，两位女主的爱情也是片中反复提及的俄耳普斯与欧律提刻的故事的一种投射。俄耳普斯做了诗人的选择，选择记住欧律提刻的美，于是再也没有在阳间见到欧律提刻。 卡罗尔 其他有一些有独到亮点的百合电影","link":"/2021/05/18/lily/"},{"title":"物语杂谈","text":"源氏物语平家物语落洼物语伊势物语交野少将物语雨月物语竹取物语春雨物语","link":"/2021/05/20/monogatari/"},{"title":"鬼才李碧华的审美取向","text":"七成饱，三分醉，十足收成；过上等生活，付中等劳力，享下等情欲。 李碧华也许是上世纪作品商业化最成功的几位作家之一。虽然不比‘飞雪连天射白鹿，笑书神侠倚碧鸳’的金庸先生，以及一代女孩追捧的琼瑶女士，但将李碧华的作品一一数来，也足够令人赞叹此人超绝的才华。 霸王别姬 青蛇 胭脂扣 古今大战秦俑情 生死桥 潘金莲的前世今生 饺子 川岛芳子 … 上世纪华语圈的帅哥美女们纷纷入戏，成为李碧华笔下的痴男怨女，在大荧幕上开始一场又一场充满无法挣脱的宿命感的纠缠。 如果用几个词来概括李碧华笔下的情，我觉得该是“痴狂”和“决绝”。李女士要的永远是为爱痴狂，永远保持烈火烹油、鲜花着锦之盛。爱情一旦过渡到柴米油盐，就如从华清池跌入泥潭，从纯白无暇到满身泥泞，人会开始真正审视自己的处境，从此感情势必就失去了一切激情和魅力。为了永远保持这份激情，不如在最顶峰的时候，一气把它斩断，要人永远记住最炙热最颠狂的时分。 胭脂扣，十二少与如花，张国荣和梅艳芳，如果真能双双殉情也罢，怕就怕一人独活下来，苟且偷生。","link":"/2021/05/18/LBH/"},{"title":"TicketMaster刷票器","text":"疫情期间奋发图强，写了一个专门爬取东航余票的程序，但因为是第一次接触，所以做的非常粗糙，也毫不具有实用性，所以现在想要改进/重塑这个程序，使之能够在实际生活中使用。 Previous：持续爬取网站余票信息，如果有符合条件的，即发送消息到指定邮箱，提醒购票。这里就存在几个问题。 东航有反爬机制，有很大概率被封IP, 而且封一次长达几天之久。 使用IP代理大部分需要付费，免费IP的质量很差，有效时间也很多，需要额外维护程序来抓取新的免费IP，并持续的检查IP是否有效。 发送提醒购票信息这种操作并不及时，不能解决我们抢票的需求。需要实现以下功能：当程序发现可选余票时，要模仿点击操作，将该票锁住。","link":"/2021/08/06/ticketmaster/"},{"title":"初学算法：链接表题目汇总","text":"以下是leetcode中，我觉得难度适中的几道链接表题目，在这里记录下来，以供未来复习之用。 EASY:Leetcode: 21 Merge Two Sorted ListsMerge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists. Iteration方法，注意循环到最后，将l1或l2剩余的部分链接到末。123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: # iteration prehead = ListNode(-1) prev = prehead while l1 and l2: if l1.val &lt; l2.val: prev.next = l1 prev = prev.next l1 = l1.next else: prev.next = l2 prev = prev.next l2 = l2.next if l1 is not None: prev.next = l1 else: prev.next = l2 return prehead.next Leetcode: 141 Linked List CycleGiven head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. set 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def hasCycle(self, head: ListNode) -&gt; bool: nodes_seen = set() while head is not None: if head in nodes_seen: return True nodes_seen.add(head) head = head.next return False two runner 12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def hasCycle(self, head: ListNode) -&gt; bool: if head is None: return False fast = head.next slow = head while fast != slow: if fast is None or fast.next is None: return False fast = fast.next.next slow = slow.next return True Leetcode: 160 Intersection of Two Linked ListsGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: The inputs to the judge are given as follows (your program is not given these inputs): intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.listA - The first linked list.listB - The second linked list.skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Hash table 12345678910111213class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: nodeB = set() while headB is not None: nodeB.add(headB) headB = headB.next while headA is not None: if headA in nodeB: return headA headA = headA.next return None Two runner解析：https://leetcode.com/problems/intersection-of-two-linked-lists/solution/ 1234567891011121314151617class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: pA = headA pB = headB while pA != pB: if pA is None: pA = headB else: pA = pA.next if pB is None: pB = headA else: pB = pB.next return pA Leetcode: 203Leetcode: 206 Reverse Linked ListGiven the head of a singly linked list, reverse the list, and return the reversed list. Iteration 1234567891011121314151617class Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head is None or head.next is None: return head left = None mid = head right = head.next while right is not None: mid.next = left left = mid mid = right right = right.next mid.next = left return mid Clean version 123456789def reverseList(self, head): previous = None current = head while current is not None: next_node = current.next current.next = previous previous = current current = next_node return previous Recursion: 注意在这里p传递了linked-list的最后一个节点，也就是新的链头 123456789class Solution: def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head is None or head.next is None: return head p = self.reverseList(head.next) head.next.next = head head.next = None return p Leetcode: 234 Palindrome Linked List (*)Given the head of a singly linked list, return true if it is a palindrome.Like 1 -&gt; 2 -&gt; 2 -&gt; 1 Python 方法 = Copy into Array List and then Use Two Pointer Technique 1234567def isPalindrome(self, head: ListNode) -&gt; bool: vals = [] current_node = head while current_node is not None: vals.append(current_node.val) current_node = current_node.next return vals == vals[::-1] Recursive (great animation at https://leetcode.com/problems/palindrome-linked-list/solution/) (*)If we iterate the nodes in reverse using recursion, and iterate forward at the same time using a variable outside the recursive function, then we can check whether or not we have a palindrome. 1234567891011121314def isPalindrome(self, head: ListNode) -&gt; bool: self.front_pointer = head def recursively_check(current_node=head): if current_node is not None: if not recursively_check(current_node.next): return False if self.front_pointer.val != current_node.val: return False self.front_pointer = self.front_pointer.next return True return recursively_check() Reverse the second halfThe only way we can avoid using O(n) extra space is by modifying the input in-place. The above two solution are all O(n) space. The strategy we can use is to reverse the second half of the Linked List in-place (modifying the Linked List structure), and then comparing it with the first half. Afterwards, we should re-reverse the second half and put the list back together. While you don’t need to restore the list to pass the test cases, it is still good programming practice because the function could be a part of a bigger program that doesn’t want the Linked List broken. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head is None: return True # Find the end of first half and reverse second half. first_half_end = self.end_of_first_half(head) second_half_start = self.reverse_list(first_half_end.next) # Check whether or not there's a palindrome. result = True first_position = head second_position = second_half_start while result and second_position is not None: if first_position.val != second_position.val: result = False first_position = first_position.next second_position = second_position.next # Restore the list and return the result. first_half_end.next = self.reverse_list(second_half_start) return result def end_of_first_half(self, head): fast = head slow = head while fast.next is not None and fast.next.next is not None: fast = fast.next.next slow = slow.next return slow def reverse_list(self, head): previous = None current = head while current is not None: next_node = current.next current.next = previous previous = current current = next_node return previous end_of_first_half 和 reverse_list两个function值得借鉴 MEDIUMLeetcode: 19 Remove Nth Node From End of ListGiven the head of a linked list, remove the nth node from the end of the list and return its head. One Pass: 前后两个相邻n的指针 123456789101112class Solution: def removeNthFromEnd(self, head, n): fast = slow = head for _ in range(n): fast = fast.next if not fast: return head.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head Two pass: 一个pass算LL的长度，一个pass来remove 1234567891011121314151617181920212223class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]: if head.next is None: if n==1: return None p1 = head l = 0 while p1: l += 1 p1 = p1.next p2 = head if l-n-1&gt;=0: for i in range(l-n-1): p2 = p2.next p2.next = p2.next.next else: return head.next return head Leetcode: 24 Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) Iterative 1234567891011121314151617181920class Solution: def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head is None or head.next is None: return head prehead = ListNode(0) prehead.next = head prev = prehead while head and head.next: first = head second = head.next prev.next = second first.next = second.next second.next = first prev = first head = first.next return prehead.next RecursionMy solution 123456789101112131415161718192021222324252627class Solution: def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head is None or head.next is None: return head prehead = ListNode(0) prehead.next = head prev = prehead def swap(prev, head): if head is None or head.next is None: return head first = head second = head.next prev.next = second first.next = second.next second.next = first prev = first head = first.next return swap(prev, head) swap(prehead, head) return prehead.next Leetcode Solution 123456789101112class Solution: def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: if head is None or head.next is None: return head first = head second = head.next first.next = self.swapPairs(second.next) second.next = first return second Leetcode: 61 Rotate ListGiven the head of a linked list, rotate the list to the right by k places. Break the ring12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]: if head is None or head.next is None or k==0: return head l = 1 tail = head while tail.next: l += 1 tail = tail.next tail.next = head p2 = head for i in range(l-k%l-1): p2 = p2.next newhead = p2.next p2.next = None return newhead Leetcode: 92 Reverse Linked List II (*)Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list. Iterative Link Reversal123456789101112131415161718192021222324252627282930313233343536373839class Solution: def reverseBetween(self, head, m, n): \"\"\" :type head: ListNode :type m: int :type n: int :rtype: ListNode \"\"\" # Empty list if not head: return None # Move the two pointers until they reach the proper starting point # in the list. cur, prev = head, None while m &gt; 1: prev = cur cur = cur.next m, n = m - 1, n - 1 # The two pointers that will fix the final connections. tail, con = cur, prev # Iteratively reverse the nodes until n becomes 0. while n: third = cur.next cur.next = prev prev = cur cur = third n -= 1 # Adjust the final connections as explained in the algorithm if con: con.next = prev else: head = prev tail.next = cur return head Leetcode: 143 Reorder ListQuestion: https://leetcode.com/problems/reorder-list/ This problem is a combination of these three easy problems: Middle of the Linked List. Reverse Linked List. Merge Two Sorted Lists.123456789101112131415161718192021222324252627282930313233343536373839404142class Solution: def reorderList(self, head: Optional[ListNode]) -&gt; None: \"\"\" Do not return anything, modify head in-place instead. \"\"\" def start_of_2st_half(head): fast = head slow = head while fast and fast.next: fast = fast.next.next slow = slow.next return slow # if 1 2 3 4 5 6 then 4 is the start of 2nd half # if 1 2 3 4 5 6 7 then 4 is the start of 2nd half def reverse(head): previous = None current = head while current is not None: next_node = current.next current.next = previous previous = current current = next_node return previous startOf2 = start_of_2st_half(head) rev2 = reverse(startOf2) p1 = head p2 = rev2 while p2.next: tmp = p1.next p1.next = p2 p1 = tmp tmp = p2.next p2.next = p1 p2 = tmp return head Leetcode Solution123456789101112131415161718192021222324252627282930313233343536373839class Solution: def reorderList(self, head: Optional[ListNode]) -&gt; None: \"\"\" Do not return anything, modify head in-place instead. \"\"\" def start_of_2st_half(head): fast = head slow = head while fast and fast.next: fast = fast.next.next slow = slow.next return slow def reverse(head): previous = None current = head while current is not None: next_node = current.next current.next = previous previous = current current = next_node return previous startOf2 = start_of_2st_half(head) rev2 = reverse(startOf2) p1 = head p2 = rev2 while p2.next: tmp = p1.next p1.next = p2 p1 = tmp tmp = p2.next p2.next = p1 p2 = tmp return head","link":"/2021/07/26/Linked-List/"},{"title":"Streamlit的基本操作","text":"Streamlit是目前为止，我觉得最简易、最不用花心思在呈现上的一个webapp包，让开发者可以更关注内容，而不是外观展现。本文旨在记录Streamlit的基本操作，以期建立一个模板，以供未来长期反复使用。","link":"/2021/08/06/streamlit/"},{"title":"spark_intro","text":"本篇主要是《Spark快速大数据分析》一书的笔记。","link":"/2021/08/23/spark-intro/"},{"title":"Leetcode上的SQL题（Part 2）","text":"题目601. Human Traffic of Stadium:Table: Stadium Column Name Type id int visit_date date people int visit_date is the primary key for this table.Each row of this table contains the visit date and visit id to the stadium with the number of people during the visit.No two rows will have the same visit_date, and as the id increases, the dates increase as well. Write an SQL query to display the records with three or more rows with consecutive id’s, and the number of people is greater than or equal to 100 for each. Return the result table ordered by visit_date in ascending order. Answer: 1234567891011select distinct a.*from stadium ajoin stadium bjoin stadium con (c.id-b.id=1 and b.id-a.id=1)or (a.id-b.id=1 and b.id-c.id=1)or (b.id-a.id=1 and b.id-c.id=2)where a.people&gt;=100and b.people&gt;=100and c.people&gt;=100order by a.id 或者 1234567891011121314151617select id,visit_date,peoplefrom(select id, visit_date, people ,count(*) over(partition by gp) as cntfrom(select *, id-flg as gpfrom(select *, dense_rank() over(order by id) as flgfrom stadiumwhere people&gt;=100) t1) t2) t3where cnt&gt;=3 Insights:后一种做法可以适用于任何连续时长 题目603. Consecutive Available Seats:Several friends at a cinema ticket office would like to reserve consecutive available seats.Can you help to query all the consecutive available seats order by the seat_id using the following cinema table? seat_id free 1 1 2 0 3 1 4 1 5 1 Your query should return the following result for the sample case above. seat_id 3 4 5 Note:The seat_id is an auto increment int, and free is bool (‘1’ means free, and ‘0’ means occupied.).Consecutive available seats are more than 2(inclusive) seats consecutively available.Answer: 1234567select c1.seat_idfrom cinema c1left join cinema c2on c1.seat_id+1=c2.seat_idleft join cinema c3on c1.seat_id-1=c3.seat_idwhere c1.free=1 and (c2.free=1 or c3.free=1) 或者 12345678910111213141516select seat_idfrom(select seat_id, count(*) over(partition by gp) as cntfrom(select * , seat_id-flg as gpfrom(select *, dense_rank() over(order by seat_id) as flgfrom cinemawhere free=1)t)t2)t3where cnt&gt;=2 Insights:后一种做法可以适用于任何连续时长 题目1127. User Purchase Platform:Table: Spending Column Name Type user_id int spend_date date platform enum amount int The table logs the spendings history of users that make purchases from an online shopping website which has a desktop and a mobile application.(user_id, spend_date, platform) is the primary key of this table.The platform column is an ENUM type of (‘desktop’, ‘mobile’).Write an SQL query to find the total number of users and the total amount spent using mobile only, desktop only and both mobile and desktop together for each date. The query result format is in the following example: Spending table: user_id spend_date platform amount 1 2019-07-01 mobile 100 1 2019-07-01 desktop 100 2 2019-07-01 mobile 100 2 2019-07-02 mobile 100 3 2019-07-01 desktop 100 3 2019-07-02 desktop 100 Result table: spend_date platform total_amount total_users 2019-07-01 desktop 100 1 2019-07-01 mobile 100 1 2019-07-01 both 200 1 2019-07-02 desktop 100 1 2019-07-02 mobile 100 1 2019-07-02 both 0 0 On 2019-07-01, user 1 purchased using both desktop and mobile, user 2 purchased using mobile only and user 3 purchased using desktop only.On 2019-07-02, user 2 purchased using mobile only, user 3 purchased using desktop only and no one purchased using both platforms. Answer: 123456789101112131415161718192021222324252627282930313233SELECT p.spend_date, p.platform, IFNULL(SUM(amount), 0) total_amount, COUNT(user_id) total_usersFROM( SELECT DISTINCT(spend_date), 'desktop' platform FROM Spending UNION SELECT DISTINCT(spend_date), 'mobile' platform FROM Spending UNION SELECT DISTINCT(spend_date), 'both' platform FROM Spending) pLEFT JOIN ( SELECT spend_date, user_id, IF(mobile_amount &gt; 0, IF(desktop_amount &gt; 0, 'both', 'mobile'), 'desktop') platform, (mobile_amount + desktop_amount) amount FROM ( SELECT spend_date, user_id, SUM(CASE platform WHEN 'mobile' THEN amount ELSE 0 END) mobile_amount, SUM(CASE platform WHEN 'desktop' THEN amount ELSE 0 END) desktop_amount### 将竖形数据改成横型数据 FROM Spending GROUP BY spend_date, user_id ) o) tON p.platform=t.platform AND p.spend_date=t.spend_dateGROUP BY spend_date, platform Insights: 用case when将竖向数据改成横向数据 两个union的subquery避免有因为数据为0而消失的行 题目597. Friend Request I: Overall Acceptance Rate:Table: FriendRequest Column Name Type sender_id int send_to_id int request_date date There is no primary key for this table, it may contain duplicates.This table contains the ID of the user who sent the request, the ID of the user who received the request, and the date of the request. Table: RequestAccepted Column Name Type requester_id int accepter_id int accept_date date There is no primary key for this table, it may contain duplicates.This table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted. Write an SQL query to find the overall acceptance rate of requests, which is the number of acceptance divided by the number of requests. Return the answer rounded to 2 decimals places. Note that:The accepted requests are not necessarily from the table friend_request. In this case, you just need to simply count the total accepted requests (no matter whether they are in the original requests), and divide it by the number of requests to get the acceptance rate.It is possible that a sender sends multiple requests to the same receiver, and a request could be accepted more than once. In this case, the ‘duplicated’ requests or acceptances are only counted once.If there are no requests at all, you should return 0.00 as the accept_rate. Follow up: Could you write a query to return the acceptance rate for every month? Could you write a query to return the cumulative acceptance rate for every day? Answer: 123selectround(ifnull((select count(distinct requester_id, accepter_id) from request_accepted)/(select count(distinct sender_id, send_to_id) from friend_request),0),2 )as accept_rate Follow-Up 1: 12345select if(d.req =0, 0.00, round(c.acp/d.req,2)) as accept_rate, c.month from(select count(distinct requester_id, accepter_id) as acp, Month(accept_date) as month from request_accepted) c,(select count(distinct sender_id, send_to_id) as req, Month(request_date) as month from friend_request) dwhere c.month = d.monthgroup by c.month Follow-Up 2: 12345678910111213141516171819202122## sum up the case when ind is 'a', which means it belongs to accept table, divided by sum of ind is 'r', which means it belong to request tableselect s.date1, ifnull(round(sum(case when t.ind = 'a' then t.cnt else 0 end)/sum(case when t.ind = 'r' then t.cnt else 0 end),2),0)from## get a table of all unique dates(select distinct x.request_date as date1 from friend_request x## The reason here use union sicne we don't want duplicate dateunion select distinct y.accept_date as date1 from request_accepted y) s## left join to make sure all dates are in the final outputleft join## get a table of all dates, count of each days, ind to indicate which table it comes from(select v.request_date as date1, count(*) as cnt,'r' as ind from friend_request v group by v.request_date## The reason here use union all sicne union all will be fasterunion allselect w.accept_date as date1, count(*) as cnt,'a' as ind from request_accepted w group by w.accept_date) t## s.date1 &gt;= t.date1, which for each reacord in s, it will join with all records earlier than it in ton s.date1 &gt;= t.date1# group by s.date1 then we can get a cumulative result to that daygroup by s.date1order by s.date1; Insights: distinct xx,xx IFNULL的用法 Cartesian product union all is faster than union 因为不需要去重 on后面接不等式 -&gt; 来计算cumulative -&gt; 效率较低 -&gt; 考虑用窗口函数代替 题目1083. Sales Analysis II:table: Product Column Name Type product_id int product_name varchar unit_price int — — product_id is the primary key of this table. Table: Sales Column Name Type seller_id int product_id int buyer_id int sale_date date quantity int price int This table has no primary key, it can have repeated rows.product_id is a foreign key to Product table. Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table. Answer: 1234567select buyer_idfrom Sales sjoin Product pon s.product_id=p.product_idgroup by buyer_idhaving sum(case product_name when \"S8\" then 1 else 0 end)&gt;0and sum(case product_name when \"iPhone\" then 1 else 0 end)=0 Insights: 题目1479. Sales by Day of the Week:Table: Orders Column Name Type order_id int customer_id int order_date date item_id varchar quantity int (ordered_id, item_id) is the primary key for this table.This table contains information of the orders placed.order_date is the date when item_id was ordered by the customer with id customer_id. Table: Items Column Name Type item_id varchar item_name varchar item_category varchar item_id is the primary key for this table.item_name is the name of the item.item_category is the category of the item. You are the business owner and would like to obtain a sales report for category items and day of the week. Write an SQL query to report how many units in each category have been ordered on each day of the week. Return the result table ordered by category. Answer: 12345678910111213select item_category as Category,ifnull(sum((case when weekday(order_date)=0 then 1 else 0 end)*quantity),0) as Monday,ifnull(sum((case when weekday(order_date)=1 then 1 else 0 end)*quantity),0) as Tuesday,ifnull(sum((case when weekday(order_date)=2 then 1 else 0 end)*quantity),0) as Wednesday,ifnull(sum((case when weekday(order_date)=3 then 1 else 0 end)*quantity),0) as Thursday,ifnull(sum((case when weekday(order_date)=4 then 1 else 0 end)*quantity),0) as Friday,ifnull(sum((case when weekday(order_date)=5 then 1 else 0 end)*quantity),0) as Saturday,ifnull(sum((case when weekday(order_date)=6 then 1 else 0 end)*quantity),0) as Sundayfrom Items ileft join Orders oon o.item_id=i.item_idgroup by Categoryorder by Category Insights:注意ifnull 题目1321. Restaurant Growth:Table: Customer Column Name Type customer_id int name varchar visited_on date amount int (customer_id, visited_on) is the primary key for this table.This table contains data about customer transactions in a restaurant.visited_on is the date on which the customer with ID (customer_id) have visited the restaurant.amount is the total paid by a customer. You are the restaurant owner and you want to analyze a possible expansion (there will be at least one customer every day). Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) . The query result format is in the following example: Return result table ordered by visited_on. average_amount should be rounded to 2 decimal places, all dates are in the format (‘YYYY-MM-DD’). Customer table: customer_id name visited_on amount 1 Jhon 2019-01-01 100 2 Daniel 2019-01-02 110 3 Jade 2019-01-03 120 4 Khaled 2019-01-04 130 5 Winston 2019-01-05 110 6 Elvis 2019-01-06 140 7 Anna 2019-01-07 150 8 Maria 2019-01-08 80 9 Jaze 2019-01-09 110 1 Jhon 2019-01-10 130 3 Jade 2019-01-10 150 Result table: visited_on amount average_amount 2019-01-07 860 122.86 2019-01-08 840 120 2019-01-09 840 120 2019-01-10 1000 142.86 1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.862nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 1203rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 1204th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86 Answer: 1234567select c1.visited_on, sum(c2.day_sum) as amount, round(avg(c2.day_sum),2) as average_amountfrom(select visited_on, sum(amount) as day_sum from Customer group by visited_on) c1,(select visited_on, sum(amount) as day_sum from Customer group by visited_on) c2where datediff(c1.visited_on,c2.visited_on) between 0 and 6group by c1.visited_onhaving count(c2.visited_on)=7 Insights: datadiff前一个参数比后一个参数在日期上更早 between 0 and 6 是大于等于0并小于等于6 因为这里要left join，所以必须先算出每日的sum，否则c1.visited_on可能会有不止七个c2.visit_on 题目1164. Product Price at a Given Date:Table: Products Column Name Type product_id int new_price int change_date date (product_id, change_date) is the primary key of this table.Each row of this table indicates that the price of some product was changed to a new price at some date. Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10. Answer: 12345678SELECT distinct a.product_id,ifnull(temp.new_price,10) as priceFROM products as aLEFT JOIN(SELECT *FROM productsWHERE (product_id, change_date) in (select product_id,max(change_date) from products where change_date&lt;=\"2019-08-16\" group by product_id)) as temp# 同时 in 两个columnon a.product_id = temp.product_id; 或者 1234567891011select t1.product_id, ifnull(new_price, 10) as pricefrom(select distinct product_id from Products) t1left join(select * from(select *, rank() over(partition by product_id order by change_date desc) as myrankfrom Products pwhere change_date &lt;= '2019-08-16')testwhere myrank=1)t2on t1.product_id=t2.product_id Insights: (xx,yy) in (zz,mm) 可以同时in多个变量 两种方法中的select distinct + left join都避免因为null而漏行 题目1135. Create a Seesion Bar Chart:Table: Sessions Column Name Type session_id int duration int session_id is the primary key for this table.duration is the time in seconds that a user has visited the application. You want to know how long a user visits your application. You decided to create bins of “[0-5&gt;”, “[5-10&gt;”, “[10-15&gt;” and “15 minutes or more” and count the number of sessions on it. Write an SQL query to report the (bin, total) in any order. The query result format is in the following example. Sessions table: session_id duration 1 30 2 199 3 299 4 580 5 1000 Result table: bin total [0-5&gt; 3 [5-10&gt; 1 [10-15&gt; 0 15 or more 1 For session_id 1, 2 and 3 have a duration greater or equal than 0 minutes and less than 5 minutes.For session_id 4 has a duration greater or equal than 5 minutes and less than 10 minutes.There are no session with a duration greater or equial than 10 minutes and less than 15 minutes.For session_id 5 has a duration greater or equal than 15 minutes.Answer: 1234SELECT '[0-5&gt;' AS bin, SUM(CASE WHEN duration &gt;= 0 AND duration &lt; 300 THEN 1 ELSE 0 END) AS total FROM Sessions UNIONSELECT '[5-10&gt;' AS bin, SUM(CASE WHEN duration &gt;= 300 AND duration &lt; 600 THEN 1 ELSE 0 END) AS total FROM Sessions UNIONSELECT '[10-15&gt;' AS bin, SUM(CASE WHEN duration &gt;= 600 AND duration &lt; 900 THEN 1 ELSE 0 END) AS total FROM Sessions UNIONSELECT '15 or more' AS bin, SUM(CASE WHEN duration &gt;= 900 THEN 1 ELSE 0 END) AS total FROM Sessions 或者 12345678910111213141516171819select T1.BIN,ifnull(total,0) as TOTAL from( SELECT \"[0-5&gt;\" AS BIN UNION SELECT \"[5-10&gt;\" AS BIN UNION SELECT \"[10-15&gt;\" AS BIN UNION SELECT \"15 or more\" AS BIN) T1left join(select (case when duration/60&lt;5 then \"[0-5&gt;\"when duration/60 &lt;10 then \"[5-10&gt;\"when duration/60 &lt;15 then \"[10-15&gt;\"else \"15 or more\" end) as bin,count(*) as totalfrom Sessionsgroup by bin) T2on T1.BIN=T2.bin Insights:case when … then … when … then … end 题目1517. Find Users With Valid E-mails:Table: Users Column Name Type user_id int name varchar mail varchar user_id is the primary key for this table.This table contains information of the users signed up in a website. Some e-mails are invalid. Write an SQL query to find the users who have valid emails. A valid e-mail has a prefix name and a domain where:The prefix name is a string that may contain letters (upper or lower case), digits, underscore ‘_’, period ‘.’ and/or dash ‘-‘. The prefix name must start with a letter.The domain is ‘@leetcode.com’.Return the result table in any order. The query result format is in the following example. Answer: 123select*from Userswhere mail REGEXP '^[a-zA-Z][a-zA-Z0-9_.-]+@leetcode.com' Insights: REGEXP ‘xxx’ 正则表达式 题目1454. Active Users:Table Accounts: Column Name Type id int name varchar the id is the primary key for this table.This table contains the account id and the user name of each account. Table Logins: Column Name Type id int login_date date There is no primary key for this table, it may contain duplicates.This table contains the account id of the user who logged in and the login date. A user may log in multiple times in the day. Write an SQL query to find the id and the name of active users. Active users are those who logged in to their accounts for 5 or more consecutive days. Return the result table ordered by the id.Answer: 1234567# select distinct l1.id, (select name from Accounts where id=l1.id) as name# from Logins l1# join Logins l2# on l1.id=l2.id# and datediff(l2.login_date,l1.login_date) between 1 and 4# group by l1.id,l1.login_date# having count(distinct l2.login_date)=4 或者 12345678910111213141516171819# Write your MySQL query statement belowselect id,login_datefrom(select *, count(*) over(partition by id,flg) as cntfrom(select id, name, login_date,date_sub(login_date, INTERVAL dt DAY) as flgfrom(select l.id, login_date, name, dense_rank() over(partition by l.id order by login_date) as dtfrom (select distinct * from Logins) lleft joinAccounts aon a.id=l.id)t1)t2)t3where cnt&gt;=5 或者 1234567891011121314select distinct id, namefrom(select id, count(1) as cnt, name, date_sub(login_date, INTERVAL dt DAY) as flgfrom(select l.id, login_date, name, dense_rank() over(partition by l.id order by login_date) as dtfrom (select distinct * from Logins) lleft joinAccounts aon a.id=l.id)t1group by id, date_sub(login_date, INTERVAL dt DAY))testwhere cnt&gt;=5 Insights:也是求连续时间的老套路了 连续时间问题 https://zhuanlan.zhihu.com/p/349358841 https://www.cnblogs.com/jiaxinwei/p/13936273.html https://blog.csdhttp://www.itongji.cn/detail?type=99993198n.net/ganghaodream/article/details/100083543 http://www.itongji.cn/detail?type=99993198","link":"/2021/08/25/leetcode-sql-2/"},{"title":"Leetcode上的SQL题（Part 3）","text":"题目619. Biggest Single Number:Table my_numbers contains many numbers in column num including duplicated ones.Can you write a SQL query to find the biggest number, which only appears once. num 8 8 3 3 1 4 5 6 For the sample data above, your query should return the following result: num 6 Note: If there is no such number, just output null. Answer: 12345678select max(num)from(select numfrom my_numbersgroup by numhaving count(*)=1)t 或者 12345678select (select numfrom my_numbersgroup by numhaving count(*)=1order by num desclimit 1) as num Insights:在方法二中，外面套一层select 会把[]变成[nulls] 题目1555. Bank Account Summary:Table: Users Column Name Type user_id int user_name varchar credit int user_id is the primary key for this table.Each row of this table contains the current credit information for each user. Table: Transactions Column Name Type trans_id int paid_by int paid_to int amount int transacted_on date trans_id is the primary key for this table.Each row of this table contains the information about the transaction in the bank.User with id (paid_by) transfer money to user with id (paid_to). Leetcode Bank (LCB) helps its coders in making virtual payments. Our bank records all transactions in the table Transaction, we want to find out the current balance of all users and check wheter they have breached their credit limit (If their current credit is less than 0). Write an SQL query to report. user_name credit, current balance after performing transactions. credit_limit_breached, check credit_limit (“Yes” or “No”) Return the result table in any order. The query result format is in the following example.Answer: 123456789101112131415select u.user_id, u.user_name, credit+ifnull(total,0) as credit,if(credit+ifnull(total,0)&gt;0,'No','Yes') as credit_limit_breachedfrom Users uleft join(select user_id, sum(amount) as totalfrom((select paid_by as user_id, -amount as amountfrom Transactions)union all(select paid_to as user_id, amountfrom Transactions) )agroup by user_id) bon u.user_id=b.user_id 或者 12345678select *,(case when CREDIT&gt;=0 then 'No' else 'Yes' end) as CREDIT_LIMIT_BREACHED from(select USER_ID, USER_NAME, credit+ifnull(sum(case when u.user_id=t1.paid_by then -amount else amount end),0) as CREDITfrom Users uleft join Transactions t1on u.user_id=t1.paid_by or u.user_id=t1.paid_togroup by user_id) test Insights:注意union all和union的区别 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。 排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。 题目608. Tree Node:Given a table tree, id is identifier of the tree node and p_id is its parent node’s id. id p_id 1 null 2 1 3 1 4 2 5 2 Each node in the tree can be one of three types:Leaf: if the node is a leaf node.Root: if the node is the root of the tree.Inner: If the node is neither a leaf node nor a root node. Write a query to print the node id and the type of the node. Sort your output by the node id. The result for the above sample is: id Type 1 Root 2 Inner 3 Leaf 4 Leaf 5 Leaf Answer: 1234567891011121314select distinct t1.id,(case when t3.id is null then 'Root'when t2.id is null then 'Leaf'else 'Inner' end) as Typefromtree t1left jointree t2on t2.p_id = t1.id # t2是t1的childleft jointree t3on t3.id = t1.p_id # t3是t1的parent Insights:Note the difference between isnull(expr,xxxx) and Is null and is not null 题目1285. Find the Start and End Number of Continious Ranges:Table: Logs Column Name Type log_id int id is the primary key for this table.Each row of this table contains the ID in a log Table. Since some IDs have been removed from Logs. Write an SQL query to find the start and end number of continuous ranges in table Logs. Order the result table by start_id. The query result format is in the following example: Logs table: log_id 1 2 3 7 8 10 Result table: start_id end_id 1 3 7 8 10 10 The result table should contain all ranges in table Logs.From 1 to 3 is contained in the table.From 4 to 6 is missing in the tableFrom 7 to 8 is contained in the table.Number 9 is missing in the table.Number 10 is contained in the table.Answer: 1234567select min(log_id) as start_id, max(log_id) as end_idfrom(select *, rank() over(order by log_id) as myrankfrom Logs) tgroup by log_id-myrank Insights: 题目1501. Countries You Can Safely Invest In:Table Person: Column Name Type id int name varchar phone_number varchar id is the primary key for this table.Each row of this table contains the name of a person and their phone number.Phone number will be in the form ‘xxx-yyyyyyy’ where xxx is the country code (3 characters) and yyyyyyy is the phone number (7 characters) where x and y are digits. Both can contain leading zeros. Table Country: Column Name Type name varchar country_code varchar country_code is the primary key for this table.Each row of this table contains the country name and its code. country_code will be in the form ‘xxx’ where x is digits. Table Calls: Column Name Type caller_id int callee_id int duration int There is no primary key for this table, it may contain duplicates.Each row of this table contains the caller id, callee id and the duration of the call in minutes. caller_id != callee_id A telecommunications company wants to invest in new countries. The company intends to invest in the countries where the average call duration of the calls in this country is strictly greater than the global average call duration. Write an SQL query to find the countries where this company can invest. Return the result table in any order.Answer: 12345678910111213141516elect c.name as countryfrom(select * fromCallsUNION ALLselect callee_id, caller_id, durationfromCalls) templeft join Person pon temp.caller_id=p.idleft join Country con substr(phone_number,1,3)=c.country_codegroup by c.namehaving avg(duration)&gt;(select avg(duration) from Calls) 或者使用CTE 123456789101112131415with CTE as(select * from Callsunion allselect callee_id, caller_id, durationfrom Calls)select c.name as countryfrom CTEleft join Person pon p.id=CTE.caller_idleft join Country con substring(p.phone_number,1,3)=c.country_codegroup by c.namehaving avg(duration)&gt;(select avg(duration) from Calls) 或者 12345678elect c.name as countryfrom Country cjoin Person pon substr(p.phone_number,1,3)=c.country_codejoin Calls caon p.id in (ca.caller_id,ca.callee_id)group by countryhaving avg(duration)&gt; (select avg(duration) from Calls) Insights:CTE只是一种retain罢了 题目1811. Find Interview CandidatesTable: Contests Column Name Type contest_id int gold_medal int silver_medal int bronze_medal int contest_id is the primary key for this table.This table contains the LeetCode contest ID and the user IDs of the gold, silver, and bronze medalists.It is guaranteed that any consecutive contests have consecutive IDs and that no ID is skipped. Table: Users Column Name Type user_id int mail varchar name varchar user_id is the primary key for this table.This table contains information about the users. Write an SQL query to report the name and the mail of all interview candidates. A user is an interview candidate if at least one of these two conditions is true: The user won any medal in three or more consecutive contests.The user won the gold medal in three or more different contests (not necessarily consecutive).Return the result table in any order.Answer: 123456789101112select name, mailfrom Contests c join Users u1on c.gold_medal=u1.user_idgroup by gold_medalhaving count(*)&gt;=3unionselect name,mailfrom Users u , Contests c1 , Contests c2, Contests c3where u.user_id in (c1.gold_medal, c1.silver_medal, c1.bronze_medal) and u.user_id in (c2.gold_medal, c2.silver_medal, c2.bronze_medal) and u.user_id in (c3.gold_medal, c3.silver_medal, c3.bronze_medal) and c1.contest_id-1 = c2.contest_id and c2.contest_id-1 = c3.contest_id Insights: union会自己去重 in的用法 题目569. Median Employee Salary Hard:The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary. Id Company Salary 1 A 2341 2 A 341 3 A 15 4 A 15314 5 A 451 6 A 513 7 B 15 8 B 13 9 B 1154 10 B 1345 11 B 1221 12 B 234 13 C 2345 14 C 2645 15 C 2645 16 C 2652 17 C 65 Write a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions. Id Company Salary 5 A 451 6 A 513 12 B 234 9 B 1154 14 C 2645 Answer: 123456789select Id, Company, Salaryfrom(select *,row_number() over(partition by Company order by Salary,id) as myasc,row_number() over(partition by Company order by Salary desc, id desc) as mydescfrom Employee e) testwhere myasc between mydesc-1 and mydesc+1order by Company,Salary Insights: 题目1777. Product’s Price For Each Store:Table: Products Column Name Type product_id int store enum price int (product_id,store) is the primary key for this table.store is an ENUM of type (‘store1’, ‘store2’, ‘store3’) where each represents the store this product is available at.price is the price of the product at this store. Write an SQL query to find the price of each product in each store. Return the result table in any order. The query result format is in the following example: Products table: product_id store price 0 store1 95 0 store3 105 0 store2 100 1 store1 70 1 store3 80 Result table: product_id store1 store2 store3 0 95 100 105 1 70 null 80 Product 0 price’s are 95 for store1, 100 for store2 and, 105 for store3.Product 1 price’s are 70 for store1, 80 for store3 and, it’s not sold in store2.Answer: 1234567select product_id,sum(case when store='store1' then price end) as store1,sum(case when store='store2' then price end) as store2,sum(case when store='store3' then price end) as store3from Products pgroup by product_id Insights: if no sum and keep group by: 那么只会留下每个product_id的第一行 if no sum and no group by：那么每个id会对应很多行 题目1613. Find the Missing IDs:Table: Customers Column Name Type customer_id int customer_name varchar customer_id is the primary key for this table.Each row of this table contains the name and the id customer. Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table. Notice that the maximum customer_id will not exceed 100. Return the result table ordered by ids in ascending order. The query result format is in the following example. Customers table: customer_id customer_name 1 Alice 4 Bob 5 Charlie Result table: ids 2 3 The maximum customer_id present in the table is 5, so in the range [1,5], IDs 2 and 3 are missing from the table. Answer: 123456WITH RECURSIVE seq AS ( SELECT 1 AS value UNION ALL SELECT value + 1 FROM seq WHERE value &lt; (select max(customer_id) from Customers) )select value as ids from seqwhere value not in(select customer_id from Customers) Insights:注意recursive的用法 题目1783. Grand Slam Titles:Table: Players Column Name Type player_id int player_name varchar — — player_id is the primary key for this table. Each row in this table contains the name and the ID of a tennis player. Table: Championships Column Name Type year int Wimbledon int Fr_open int US_open int Au_open int year is the primary key for this table.Each row of this table containts the IDs of the players who won one each tennis tournament of the grand slam. Write an SQL query to report the number of grand slam tournaments won by each player. Do not include the players who did not win any tournament. Return the result table in any order.Answer: 1234567891011SELECT *FROM (SELECTplayer_id,player_name,SUM( CASE WHEN player_id = Wimbledon THEN 1 ELSE 0 END + CASE WHEN player_id = Fr_open THEN 1 ELSE 0 END + CASE WHEN player_id = US_open THEN 1 ELSE 0 END + CASE WHEN player_id = Au_open THEN 1 ELSE 0 END ) AS grand_slams_countFROM Players CROSS JOIN Championships GROUP BY player_id, player_name ) TWHERE grand_slams_count &gt; 0 或者CTE 123456789101112131415 CTE: WITH CTE AS ( SELECT Wimbledon AS id FROM Championships UNION ALL SELECT Fr_open AS id FROM Championships UNION ALL SELECT US_open AS id FROM Championships UNION ALL SELECT Au_open AS id FROM Championships )SELECT player_id,player_name,COUNT(*) AS grand_slams_countFROM Players INNER JOIN CTE ON Players.player_id = CTE.idGROUP BY player_id, Insights:Cross Join = 直接中间放个逗号 = cartesian product 题目1107. New Users Daily Count:Table: Traffic Column Name Type user_id int activity enum activity_date date There is no primary key for this table, it may have duplicate rows.The activity column is an ENUM type of (‘login’, ‘logout’, ‘jobs’, ‘groups’, ‘homepage’). Write an SQL query that reports for every date within at most 90 days from today, the number of users that logged in for the first time on that date. Assume today is 2019-06-30. The query result format is in the following example: Traffic table: user_id activity activity_date 1 login 2019-05-01 1 homepage 2019-05-01 1 logout 2019-05-01 2 login 2019-06-21 2 logout 2019-06-21 3 login 2019-01-01 3 jobs 2019-01-01 3 logout 2019-01-01 4 login 2019-06-21 4 groups 2019-06-21 4 logout 2019-06-21 5 login 2019-03-01 5 logout 2019-03-01 5 login 2019-06-21 5 logout 2019-06-21 Result table: login_date user_count 2019-05-01 1 2019-06-21 2 Note that we only care about dates with non zero user count.The user with id 5 first logged in on 2019-03-01 so he’s not counted on 2019-06-21.Answer: 123456789select login_date, count(1) user_countfrom(select user_id, min(activity_date) login_datefrom trafficwhere activity = 'login'group by user_id) awhere datediff('2019-06-30',login_date)&lt;=90group by login_date Insights: datadiff 后面的时间比前面的时间大 count(1) 和 count(*) 题目585. Investments in 2016:Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria: Have the same TIV_2015 value as one or more other policyholders.Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).Input Format:The insurance table is described as follows: Column Name Type PID INTEGER(11) TIV_2015 NUMERIC(15,2) TIV_2016 NUMERIC(15,2) LAT NUMERIC(5,2) LON NUMERIC(5,2) where PID is the policyholder’s policy ID, TIV_2015 is the total investment value in 2015, TIV_2016 is the total investment value in 2016, LAT is the latitude of the policy holder’s city, and LON is the longitude of the policy holder’s city. Sample Input PID TIV_2015 TIV_2016 LAT LON 1 10 5 10 10 2 20 20 20 20 3 10 30 20 20 4 10 40 40 40 Sample Output TIV_2016 45.00 Answer: 1234567891011121314151617181920212223SELECT SUM(insurance.TIV_2016) AS TIV_2016FROM insuranceWHERE insurance.TIV_2015 IN ( SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) &gt; 1 ) AND CONCAT(LAT, LON) IN ( SELECT CONCAT(LAT, LON) FROM insurance GROUP BY LAT , LON HAVING COUNT(*) = 1 ) Insights:","link":"/2021/08/26/leetcode-sql-3/"},{"title":"SQL调优和注意事项（上）","text":"基本知识SQL调优的基本原则“二八原理” 是一个普遍的真理，特别是在计算机的世界中表现的更加明显，那就是20%的代码的资源消耗占用了80%的总资源消耗。SQL语句也是一种代码，因此它也符合这个原理。在进行SQL调优的时候应该把主要精力放到这20%的最消耗系统资 源的SQL语句中，不要想把所有的SQL语句都调整到最优状态。很多DBMS都提供了非常好的工具用来分析系统中所有SQL语句资源消耗的工具，借助于这些工具发现占用系统资源排在前面的SQL语句，然后尝试对它们进行优化，优化后再次执行分析，迭代这一过程，直到系统中没有明显的系统资源消耗异常的SQL语句为止。 索引索引是数据库调优的最根本的优化方法，很多优化手法都是围绕索引展开的，可以说索引是一切优化手法的“内功”，而所有的优化手法都是由索引衍化出来的招式而已。根据索引的顺序与数据表的物理顺序是否相同，可以把索引分成两种类型：聚簇索引，数据表的物理顺序与索引顺序相同；非聚簇索引，数据表的物理顺序与索引顺序不相同。下面，我们举例来说明一下聚集索引和非聚集索引的区别：字典的目录就是一种索引，因为通过目录我们可以很快的定位到要检索的内容，而不用从头到尾把字典翻一遍。汉语字典一般都至少提供两种目录，一种是拼音目录，一种是偏旁部首目录。汉语字典是按照拼音的顺序排列的，因此拼音目录就是聚集索引，而偏旁部首目录则是非聚集索引。应该在表中经常搜索的列或者按照顺序访问的列上创建聚簇索引。当创建聚簇索引时要需要每一个表只能有一个聚簇索引，因为表中数据的物理顺序只能有一个，而非聚集索引则可以创建多个。由于索引需要占据一定的存储空间，而且索引也会降低数据插入、更新和删除的速度，所以应该只创建必要的索引，一般是在检索的时候用的字段中创建索引。索引还会造成存储碎片的问题。当删除一条记录时将会导致对应的索引中的该记录的对应项为空，由于索引是采用B树结构存储的，所以对应的索引项并不会被删除，经过一段时间的增删改操作后，数据库中就会出现大量的存储碎片，这和磁盘碎片、内 存碎片产生原理是类似的，这些存储碎片不仅占用了存储空间，而且降低了数据库运行的速度。如果发现索引中存在过多的存储碎片的话就要进行“碎片整理”了，最方便的“碎片整理”手段就是重建索引，重建索引会将先前创建的索引删除然后重新创建索引，主流数据库管理系统都提供了重建索引的功能，比如REINDEX、REBUILD等，如果 使用的数据库管理系统没有提供重建索引的功能，可以首先用DROP INDEX语句删除索引，然后用ALTER TABLE语句重新创建索引。 索引类型转自：https://segmentfault.com/a/1190000037683781 按数据结构分类MySQL索引按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。 按物理存储分类MySQL索引按叶子节点存储的是否为完整表数据分为：聚簇索引、二级索引（辅助索引）。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。 聚簇索引聚簇索引的每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。 二级索引二级索引的叶子节点并不存储一行完整的表数据，而是存储了聚簇索引所在列的值。回表查询由于二级索引的叶子节点不存储完整的表数据，索引当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据。回表查询 需要额外的 B+tree 搜索过程，必然增大查询耗时。需要注意的是，通过二级索引查询时，回表不是必须的过程，当SELECT的所有字段在单个二级索引中都能够找到时，就不需要回表，MySQL称此时的二级索引为覆盖索引或触发了索引覆盖。可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现Using index，表示查询触发了索引覆盖。 按字段特性分类MySQL索引按字段特性分类可分为：主键索引、普通索引、前缀索引。 主键索引建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。 唯一索引建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空，列值中出现多个空值不会发生重复冲突。 普通索引建立在普通字段上的索引被称为普通索引。 前缀索引前缀索引是指对字符类型字段的前几个字符或对二进制类型字段的前几个bytes建立的索引，而不是在整个字段上建索引。前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间，也能提升索引的查询效率。 按索引字段个数分类MySQL索引按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。 单列索引建立在单个列上的索引被称为单列索引。 联合索引（复合索引、组合索引）建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。 索引属性1234567891011121314151617181920212223242526272829mysql&gt; select count(*) from member_info;+----------+| count(*) |+----------+| 148416 |+----------+1 row in set (0.35 sec)mysql&gt; show index from member_base_info;+------------------+------------+----------------------------+--------------+-------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+------------------+------------+----------------------------+--------------+-------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| member_info | 0 | PRIMARY | 1 | id | A | 131088 | NULL | NULL | | BTREE | | || member_info | 0 | uk_member_id | 1 | member_id | A | 131824 | NULL | NULL | | BTREE | | || member_info | 1 | idx_create_time | 1 | create_time | A | 6770 | NULL | NULL | | BTREE | | |+------------------+------------+----------------------------+--------------+-------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+#Table： 表名#Non_unique ：是否为unique index，0-是，1-否。#Key_name：索引名称#Seq_in_index：索引中的顺序号，单列索引-都是1；复合索引-根据索引列的顺序从1开始递增。#Column_name：索引的列名#Collation：排序顺序，如果没有指定asc/desc，默认都是升序ASC。#Cardinality：索引基数-索引列唯一值的个数。#sub_part：前缀索引的长度；例如index (member_name(10)，长度就是10。#Packed：索引的组织方式，默认是NULL。#Null：YES:索引列包含Null值；'':索引不包含Null值。#Index_type：默认是BTREE，其他的值FULLTEXT，HASH，RTREE。#Comment：在索引列中没有被描述的信息，例如索引被禁用。#Index_comment：创建索引时的备注。 SQL EXPLAIN指令1234567mysql&gt; explain select * from servers;+----+-------------+---------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | servers | ALL | NULL | NULL | NULL | NULL | 1 | NULL |+----+-------------+---------+------+---------------+------+---------+------+------+-------+row in set (0.03 sec) id我的理解是SQL执行的顺序的标识,SQL从大到小的执行 id相同时，执行顺序由上至下 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行 select_type(1) SIMPLE(简单SELECT,不使用UNION或子查询等)(2) PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)(3) UNION(UNION中的第二个或后面的SELECT语句)(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)(5) UNION RESULT(UNION的结果)(6) SUBQUERY(子查询中的第一个SELECT)(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)(8) DERIVED(派生表的SELECT, FROM子句的子查询)(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)派生表DERIVED长于PRIMARY成对出现，一个内层一个外层 table显示这一步所访问数据库中表名称（表名，如果有别名就显示表的别名，派生表没有名字会生成derived+数字来代替） partition：查询表分区 type表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好） Select_type 说明查询中使用到的索引类型，如果没有用有用到索引则为all ALL Full Table Scan， MySQL将遍历全表以找到匹配的行 index Full Index Scan，index与ALL区别为index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小，也就是说虽然ALL和Index都是读全表，但Index是从索引中读取的，而ALL都是从磁盘中读的。 range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，面结束另一点，不用扫描全部索引。 ref 非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回匹配某个单独值的行，然而，它可能会找到多个符合条件的行，索引他应该属于查找和扫描的混合体 eq_ref 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件 const 表示通过索引一次就找到了，const用于比较primary key或者unique索引，因为只匹配一行数据，所以很快。如将主键置于where列表中，Mysql就能将该查询转换为一个常量 system 表只有一行记录（等于系统表），这是const类型的特别，平时不会出现 NULL MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 possible-key显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。possible-key的几个索引，可以理解为，用上了，但是没有完全用上 keykey列显示MySQL实际决定使用的键（索引），这个索引一定是SQL用到的当然他也包含在possible_keys中 key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。这个表示的是可能索引有多长，根据表定义得到的。不能代表实际表的索引长度，可能实际长度是1，但是定义了10这种情况。对SQL查询的影响：不损失精度的钱体系，索引越短效率越高，所以不是所有的东西都是越长越好是吧。当然要注意精度，比如一个Long整型的为了变短边长Integer类型的，精度缺失，得不偿失。 ref对比我们上面的访问类型type里面的唯一型索引eq_ref，ref索引对应多行结果，这个ref指的是用到的索引具体是那列。没用到就为空，用到了就把索引对应的表名加字段表示出来。 rows估计的扫描行数，最好的结果就是只扫描一行，一查就查到。但实际情况不一定允许。实际上预估的，不一定就是实际扫描的，但是也足以表示出效率瓶颈在哪，扫描行数特别多的要特别注意，是不是没走索引扫描了全表，还是选择的字段不行，比如说你查看性别男性的数据，整张表几乎都是男性。 filteredFiltered表示返回结果的行数占需读取行数的百分比 Filtered列的值越大越好 Filtered列的值依赖于统计信息举个例子，你读取的结果集100，但是结果只有10行，浪费了很多读取的数据，或者说你压根不用读取这么多，条件匹配的好，读取10行结果返回输出10行 ExtraUsing temporary: 使用了临时表中保存中间结果，Mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。Using index: 表示相应的select操作中使用了覆盖索引（Covering Index）,避免访问了表的数据行，效率不错。 如果同时出现using where: 表明索引被用于来执行索引键值的查找。 如果没有同时出现wing where，表明索引用来读取数据而非执行查找动作。Using where: 表明使用了where过滤 Using join buffer： 使用了连接缓存impossible where: where子句中的值总是false，不能用来获取任何元组 转自Reference：https://segmentfault.com/a/1190000040145951https://zhuanlan.zhihu.com/p/33019910https://www.huaweicloud.com/articles/12591002.htmlhttps://www.cnblogs.com/cnjavahome/p/4230534.htmlhttps://segmentfault.com/a/1190000038177522https://blog.csdn.net/u010520146/article/details/81161762https://www.cnblogs.com/leeego-123/p/11846613.htmlhttps://zhuanlan.zhihu.com/p/376576902","link":"/2021/08/30/sql-improvement/"},{"title":"SQL调优和注意事项（下）","text":"General Rule of thumb 要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引 在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引 一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 避免在索引上使用计算：在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询e.g. 当salary是索引列的时候，后者会比前者效率高，因为能够使用salary上的索引1select * from user where salary*22&gt;10000 1select * from user where salary&gt;10000*22 参数化sql程序，可以利用预编译节省时间，提高执行速度 尽量将多条SQL语句压缩到一句SQL中每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。 使用表的别名当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 用union all替换union当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集同样会尝试进行合并，然后在输出最终结果前进行排序并去重，因此如果可以判断检索结果中不会有重复的记录时候，应该用union all，这样效率就会因此得到提高。 考虑使用“临时表”暂存中间结果简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。 用varchar/nvarchar 代替 char/nchar尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。 只在必要的情况下才使用事务begin translationSQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。 更新Update语句优化如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志 插入Insert语句优化在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 查询select语句优化（其实就是注意不要让索引失效） 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段，这会增加网络的负载和服务器的资源消耗；即使确实需要检索所有列，也不要使用 SELECT ，因为这是一个非常低效的方法，DBMS在解析的过程中，会将依次转换成所有的列名，这意味着将耗费更多的时间 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：12select id from t where num=0select id from t where num=10 or num=20 可以这样查询（同时union all比or更不会破坏索引）：123select id from t where num=10 union allselect id from t where num=20 或者根据业务含义，尽量将字段都添加上NOT NULL DEFAULT VALUE属性，如果列值存储了大量的NULL，会影响索引的稳定性。 不能前置百分模糊搜索，如select id from t where name like ‘%abc%’ 若要提高效率，可以考虑全文检索。select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3 如果查询的两个表大小相当，那么用in和exists差别不大。例如：表A（小表），表B（大表）12select * from A where cc in (select cc from B) 效率低，用到了A表上cc列的索引； select * from A where exists(select cc from B where cc=A.cc) 效率高，用到了B表上cc列的索引。 相反的12select * from B where cc in (select cc from A) 效率高，用到了B表上cc列的索引；select * from B where exists(select cc from A where cc=B.cc) 效率低，用到了A表上cc列的索引。 总而言之尽量使用大表的索引。 UDF用户自定义函数SQL语句的select后面使用了自定义函数UDF，SQL返回多少行，那么UDF函数就会被调用多少次，这是非常影响性能的。 text类型检查如果select出现text类型的字段，就会消耗大量的网络和IO带宽，由于返回的内容过大超过max_allowed_packet设置会导致程序报错，需要评估谨慎使用 group_concat谨慎使用gorup_concat是一个字符串聚合函数，会影响SQL的响应时间，如果返回的值过大超过了max_allowed_packet设置会导致程序报错。 内联子查询在select后面有子查询的情况称为内联子查询，SQL返回多少行，子查询就需要执行过多少次，严重影响SQL性能。select id,(select rule_name from member_rule limit 1) as rule_name, member_id, member_type, member_name, status from member_info m where status = 1 and create_time between '2020-09-02 10:00:00' and '2020-10-01 10:00:00'; 避免SQL中出现隐式类型转换当某一张表中的索引字段在作为where条件的时候，如果进行了隐式类型转换，则此索引字段将会不被识别，因为隐式类型转换也属于计算，所以此时DBMS会使用全表扫面。 防止检索范围过宽如果DBMS优化器认为检索范围过宽，那么将放弃索引查找而使用全表扫描。下面几种可能造成检索范围过宽的情况。a、使用is not null或者不等于判断，可能造成优化器假设匹配的记录数太多。b、使用like运算符的时候，“a%”将会使用索引，而“a%c”和“%a”则会使用全表扫描，因此“a%c”和“%a”不能被有效的评估匹配的数量，举例：给strEmpName创建索引select * from Employee where strEmpName like ‘a%’（索引起作用）select * from Employee where strEmpName like ‘a%b’（索引不起作用）select * from Employee where strEmpName like ‘%a’（索引不起作用） 使用 VARCHAR 类型来当主键会使用得性能下降。 使用 ENUM 而不是 VARCHARENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。 固定长度的表会更快如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。 垂直分割“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。(以前，在银行做过项目，见过一张表有100多个字段，很恐怖)示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢? 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。 拆分大的 DELETE 或 INSERT 语句如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例： 越小的列会越快对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。如果一个表只会有几列罢了(比如说字典表，配置表)，那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子(2009年11月06日)，一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。 选择正确的存储引擎在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 避免隐式类型转换造成的全表扫描，即在where中对索引列做类型转换 用Where子句替换HAVING子句避免使用HAVING子句，因为HAVING 只会在检索出所有记录之后才对结果集进行过滤。如果能通过WHERE子句限制记录的数目，那就能减少这方面的开销。 HAVING 中的条件一般用于聚合函数的过滤，除此而外，应该将条件写在WHERE子句中。 调整WHERE子句中的连接顺序DBMS一般采用自下而上的顺序解析WHERE子句，根据这个原理,表连接最好写在其他WHERE条件之前，那些可以过滤掉最大数量记录的条件写在WHERE子句的末尾。比如下面的SQL语句性能较差： 1234567SELECT *FROM T_PersonWHERE FSalary &gt; 50000AND FPosition= 'MANAGER'AND 25 &lt; (SELECT COUNT(*)FROM T_ManagerWHERE FManagerId=2); 我们将子查询的条件放到最前面，下面的SQL语句性能比较好： 12345678SELECT *FROM T_PersonWHERE25 &lt; (SELECT COUNT(*)FROM T_ManagerWHERE FManagerId = 2)AND FSalary &gt; 50000AND FPosition= 'MANAGER'; 用EXISTS替代IN, 用表连接替换EXISTS在查询中，为了满足一个条件，往往需要对另一个表进行联接，在这种情况下，使用EXISTS而不是IN通常将提高查询的效率，因为IN 子句将执行一个子查询内部的排序和合并。下面的语句2就比语句1效率更加高。通常来说，表连接的方式比EXISTS更有效率，因此如果可能的话尽量使用表连接替换EXISTS。下面的语句4就比语句3效率更加高。 123456--语句1：SELECT * FROM T_EmployeeWHERE FNumber&gt; 0AND FDEPTNO IN (SELECT FNumberFROM T_DepartmentWHERE FMangerName = 'Tome') 1234567--语句2：SELECT * FROM T_Employee EMPWHERE EMP.FNumber &gt; 0AND EXISTS (SELECT 1FROM T_Department DEPWHERE DEP.FDEPTNO = EMP.FNumberAND DEP.FMangerName = 'Tome') 1234567--语句3：SELECT * FROM T_Employee EMPWHERE EMP.FNumber &gt; 0AND EXISTS (SELECT 1FROM T_Department DEPWHERE DEP.FDeptno = EMP.FNumberAND DEP.FKind = 'A') 1234--语句4：SELECT FName FROM T_Department DEP,T_Employee EMPWHERE DEP.FDeptno = EMP.FNumberAND DEP.FKind = 'A'; 利用with字句重用查询如获得工资大于平均工资的员工和工资信息： 1234567891011select * from (select employee_id,avg(salary) avg_salaryfrom salarygroup by employee_id)twhere t.avg_salary &gt;(select avg(avg_salary) from (select employee_id,avg(salary) avg_salaryfrom salarygroup by employee_id)); 可以看到子查询： 123select employee_id,avg(salary) avg_salaryfrom salarygroupby employee_id; 被重复执行，通过with子句可以将该子查询独立出来，并重用其查询结果，如下所示： 12345678with employee_avg_salary as (select employee_id,avg(salary) avg_salaryfrom salarygroup by employee_id)select * from employee_avg_salary twhere t.avg_salary &gt; (select avg(avg_salary)from employee_avg_salary); from的检查 表的链接方式在MySQL中不建议使用Left Join，即使ON过滤条件列索引，一些情况也不会走索引，导致大量的数据行被扫描，SQL性能变得很差，同时要清楚ON和Where的区别。 子查询由于MySQL的基于成本的优化器CBO对子查询的处理能力比较弱，不建议使用子查询，可以改写成Inner Join。 where检查 索引列被运算当一个字段被索引，同时出现where条件后面，是不能进行任何运算，会导致索引失效 类型转换对于Int类型的字段，传varchar类型的值是可以走索引，MySQL内部自动做了隐式类型转换；相反对于varchar类型字段传入Int值是无法走索引的，应该做到对应的字段类型传对应的值总是对的。 列字符集从MySQL 5.6开始建议所有对象字符集应该使用用utf8mb4，包括MySQL实例字符集，数据库字符集，表字符集，列字符集。避免在关联查询Join时字段字符集不匹配导致索引失效，同时目前只有utf8mb4支持emoji表情存储。 group by 检查 前缀索引group by后面的列有索引，索引可以消除排序带来的CPU开销，如果是前缀索引，是不能消除排序的。 函数运算假设需要统计某月每天的新增用户量，参考如下SQL语句，虽然可以走create_time的索引，但是不能消除排序，可以考虑冗余一个字段stats_date date类型来解决这种问题。1select DATE_FORMAT(create_time, '%Y-%m-%d'), count(*) from users where create_time between '2020-09-01 00:00:00' and '2020-09-30 23:59:59' group by DATE_FORMAT(create_time, '%Y-%m-%d'); order by 检查 前缀索引order by后面的列有索引，索引可以消除排序带来的CPU开销，如果是前缀索引，是不能消除排序的。 字段顺序排序字段顺序，asc/desc升降要跟索引保持一致，充分利用索引的有序性来消除排序带来的CPU开销。 limit检查limit m,n要慎重对于limit m, n分页查询，越往后面翻页即m越大的情况下SQL的耗时会越来越长，对于这种应该先取出主键id，然后通过主键id跟原表进行Join关联查询。 转自Reference：https://segmentfault.com/a/1190000040145951https://zhuanlan.zhihu.com/p/33019910https://www.huaweicloud.com/articles/12591002.htmlhttps://www.cnblogs.com/cnjavahome/p/4230534.htmlhttps://segmentfault.com/a/1190000038177522https://blog.csdn.net/u010520146/article/details/81161762https://www.cnblogs.com/leeego-123/p/11846613.htmlhttps://zhuanlan.zhihu.com/p/376576902","link":"/2021/09/06/sql-improvement-2/"},{"title":"mysql小知识及进阶知识","text":"入门知识查漏补缺 创建数据库 create database dbname; 查看已有数据库 show databases; 切换到某数据库 use dbname; 删除数据库 drop database dbname; 用create table tbname(id int, var1 varchar(20), sex char(2))建表，用desc tbname查看表的基本信息 查看建立表的语句show create table tbname job 删除表 drop table tbname，这种删除可以通过日志恢复，如果使用truncate table tbname则会永久删除该表 修改表结构alter table tbname modify name varchar(25);(修改已有字段的属性) or alter table tbname add newvar varchar(30);（新增字段） or alter table tbname drop column oldvar;（删除字段） or alter table tbname change old new decimal(12,2); (字段改名并改变属性) or alter table oldtbname rename newtbname(表改名)modify和change不改变字段的相对顺序，add默认加在最后，但是可以是用alter table tbname add newvar after oldvar来指定插入位置 insert一次插入多条数据12345INSERT INTO tablename (field1,field2) VALUES(value1,value2),(value1,value2),(value1,value2),...; limit m,nselect * from job order by salary desc limit 2,3 从第二条记录开始的三条记录 count(1) count(colname) count(*) count(1) 忽略所有列，用1代表每一行，不会忽略值为null count(*) 包括所有列，不会忽略值为null count(colname) 会忽略该字段中值为null的行 数据类型 参见 https://www.cnblogs.com/cxuanBlog/p/13173547.html 其他函数VERSION 返回当前数据库的版本 select version()DATABASE 返回当前数据库名USER 返回当前登陆用户名PASSWORD 返回字符串的加密版本MD5 返回 MD5 值INET_ATON(IP) 返回 IP 地址的数字表示INET_NTOA(num) 返回数字代表的 IP 地址 帮助文档的使用 需要在命令行使用 查询所有可供查询的分类 ? contents，从中发现更多可以？的内容 查询关于权限管理的命令 ? account management 查询关于数据类型 ? data types 查询关于任何命令 ? [command] Mysql 高级内容 死锁：死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态死锁产生的原因主要是： 1.系统资源不足 2.进程推进顺序非法产生死锁的必要条件： （1）互斥（mutualexclusion），一个资源每次只能被一个进程使用 （2）不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺 （3）占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放 （4）环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。足，就不会发生死锁。其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。 事务和事务表https://blog.csdn.net/H_Rhui/article/details/96917915MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！最常见的两种数据库引擎： Innodb 数据库引擎的数据库或表支持事务；MyISAM存储引擎的数据库或表不支持事务。事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。事务用来管理 insert,update,delete 语句一般来说，事务是必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务表和非事务表事务表故名思义就是支持事务的表，支不支持事务和 MySQL 的存储类型有关，一般情况下，InnoDB 存储引擎的表是支持事务的，关于 InnoDB 的知识，我们会在后面详细介绍。非事务表相应的就是不支持事务的表，在 MySQL 中，存储引擎 MyISAM 是不支持事务的，非事务表的特点是不支持回滚。SHOW ENGINES; 可检查mysqld服务器支持的存储引擎：SHOW VARIABLES LIKE ‘have_%’; 可检查与你感兴趣的存储引擎有关的变量值 锁定语句我们知道，MyISAM 和 MEMORY 存储引擎支持表级锁定(table-level locking)，InnoDB 存储引擎支持行级锁定(row-level locking)，BDB 存储引擎支持页级锁定(page-level locking)。各个锁定级别的特点如下: 页级锁：销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 表级锁：表级锁是对整张表进行加锁，MyISAM 和 MEMORY 主要支持表级锁，表级锁加锁快，不会出现死锁，锁的粒度比较粗，并发度最低 行级锁：行级锁可以说是 MySQL 中粒度最细的一种锁了，InnoDB 支持行级锁，行级锁容易发生死锁，并发度比较好，同时锁的开销也比较大。 锁定语句MySQL 的锁定语句主要有两个 Lock 和 unLock，Lock Tables 可用于锁定当前线程的表，就跟 Java 语法中的 Lock 锁的用法是一样的，如果表锁定，意味着其他线程不能再操作表，直到锁定被释放为止。lock table cxuan005 read; 锁定了cxuan005表的read锁，此时我们在另一个线程仍能进行查询，但是不能再update该表解锁语句unlock tables;，在解锁完成前，之前进行更新的线程会一直等待，直到解锁完成后，才会进行更新。 为什么行级锁容易死锁而表级锁不容易死锁 事务控制事务(Transaction) 是访问和更新数据库的基本执行单元，一个事务中可能会包含多个 SQL 语句，事务中的这些 SQL 语句要么都执行，要么都不执行，而 MySQL 它是一个关系型数据库，它自然也是支持事务的。事务同时也是区分关系型数据库和非关系型数据库的一个重要的方面。在 MySQL 事务中，主要涉及的语法包含 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等。 在mysql中，事务默认是自动提交的，可以通过show variables like 'autocommit';来检查。在该模式下，每个SQL语句都会当作一个事务执行操作set autocommit=0;可以关闭自动提交，反之set等于1，则开启自动提交。Note：这里注意一下特殊操作。在 MySQL 中，存在一些特殊的命令，如果在事务中执行了这些命令，会马上强制执行 commit 提交事务；比如 DDL 语句(create table/drop table/alter/table)、lock tables 语句等等。不过，常用的 select、insert、update 和 delete命令，都不会强制提交事务。 手动提交 123start transaction; # 一条或多条语句commit; 上面代码中的 start transaction 就是事务的开始语句，编写 SQL 后会调用 commit 提交事务，然后将事务统一执行，如果 SQL 语句出现错误会自动调用 Rollback 进行回滚。如果不commit的话，则在另一个线程，我们是看不到在当前线程下的更新的。除了 commit 之外，MySQL 中还有 commit and chain 命令，这个命令会提交当前事务并且重新开启一个新的事务。如下代码所示 123start transaction; # 开启一个新的事务insert into cxuan005(id,info) values (555,'cxuan005'); # 插入一条数据commit and chain; # 提交当前事务并重新开启一个事务 上面是一个事务操作，在 commit and chain 键入后，我们可以再次执行 SQL 语句 12update cxuan005 set info = 'cxuan' where id = 555;commit; 然后再次查询select * from cxuan005;执行后，可以发现，我们仅仅使用了一个 start transaction 命令就执行了两次事务操作。如果在手动提交的事务中，你发现有一条 SQL 语句写的不正确或者有其他原因需要回滚，那么此时你就会用到 rollback 语句，它会回滚当前事务，相当于什么也没发生。如下代码所示。 123start transaction;delete from cxuan005 where id = 555;rollback; 这样这个delete就像没发生过一样。注意，只有没commit的事务可以被rollback，一旦commit事务，则无法rollback savepointSAVEPOINT，它能指定事务回滚的一部分，但是不能指定事务提交的一部分。 SAVEPOINT 可以指定多个，在满足不同条件的同时，回滚不同的 SAVEPOINT。需要注意的是，如果定义了两个相同名称的 SAVEPOINT，则后面定义的 SAVEPOINT 会覆盖之前的定义。如果 SAVEPOINT 不再需要的话，可以通过 RELEASE SAVEPOINT 来进行删除。删除后的 SAVEPOINT 不能再执行 ROLLBACK TO SAVEPOINT 命令。我们通过一个示例来进行模拟不同的 SAVEPOINT,首先先启动一个事务 ，向 cxuan005 中插入一条数据，然后进行查询，那么是可以查询到这条记录的 123start transaction;insert into cxuan005(id,info) values(666,'cxuan666');select * from cxuan005 where id = 666; 然后我们定义一个 SAVEPOINT,savepoint test;`` 然后继续插入一条记录,insert into cxuan005(id,info) values(777,’cxuan777’); 此时就可以查询到两条新增记录了，id 是 666 和 777 的记录。 那么我们可以回滚到刚刚定义的 SAVEPOINT，通过`rollback to savepoint test;再次查询 cxuan005 这个表，可以看到，只有 id=666 的这条记录插入进来了，说明 id=777 这条记录已经被回滚了。然后我们可以commit，提交这个事务。 SQL modeSQL Mode 可以解决下面这几种问题 通过设置 SQL Mode，可以完成不同严格程度的数据校验，有效保障数据的准确性。 设置 SQL Mode 为 ANSI 模式，来保证大多数 SQL 符合标准的 SQL 语法，这样应用在不同数据库的迁移中，不需要对 SQL 进行较大的改变 数据在不同数据库的迁移中，通过改变 SQL Mode 能够更方便的进行迁移通过select @@sql_mode来查看默认的SQL mode SQL mode Definition ONLY_FULL_GROUP_BY 这个模式会对 GROUP BY 进行合法性检查，对于 GROUP BY 操作，如果在SELECT 中的列，没有在 GROUP BY 中出现，那么将认为这个 SQL 是不合法的，因为列不在 GROUP BY 从句中 STRICT_TRANS_TABLES 这就是严格模式，在这个模式下会对数据进行严格的校验，错误数据不能插入，报error 错误。如果不能将给定的值插入到事务表中，则放弃该语句。对于非事务表，如果值出现在单行语句或多行语句的第1行，则放弃该语句。 NO_ZERO_IN_DATE 这个模式影响着日期中的月份和天数是否可以为 0（注意年份是非 0 的），这个模式也取决于严格模式是否被启用。如果这个模式未启用，那么日期中的零部分被允许并且插入没有警告。如果这个模式启用，那么日期中的零部分插入被作为 0000-00-00 并且产生一个警告。这个模式需要注意下，如果启用的话，需要 STRICT_TRANS_TABLES 和 NO_ZERO_IN_DATE 同时启用，否则不起作用，也就是set session sql_mode=’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE’; ERROR_FOR_DIVISION_BY_ZERO 如果这个模式未启用，那么零除操作将会插入空值并且不会产生警告；如果这个模式启用，零除操作插入空值并产生警告；如果这个模式和严格模式都启用，零除从操作将会产生一个错误。 NO_AUTO_CREATE_USER 禁止使用 grant 语句自动创建用户，除非认证信息被指定。 NO_ENGINE_SUBSTITUTION 此模式指定当执行 create 语句或者 alter 语句指定的存储引擎没有启用或者没有编译时，控制默认存储引擎的自动切换。默认是启用状态的。 修改SQL mode1SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY','')); SQL mode的作用域SQL Mode 按作用区域和时间可分为3个级别，分别是会话级别，全局级别，配置（永久生效）级别。 我们上面使用的 SQL Mode 都是 会话级别，会话级别就是当前窗口域有效。它的设置方式是 12set @@session.sql_mode='xx_mode'set session sql_mode='xx_mode' 全局域就是当前会话关闭不失效，但是在 MySQL 重启后失效。它的设置方式是 12set global sql_mode='xx_mode';set @@global.sql_mode='xx_mode'; 配置域就是在 vi /etc/my.cnf 里面添加 12[mysqld]sql-mode = \"xx_mode\" 配置域在保存退出后，重启服务器，即可永久生效。 mysql正则表示式 * 0或多个字符串 + 1或多个字符串 ? 0或1个字符串 . 匹配任意单个字符 ^ 匹配头 $ 匹配尾 […] 表示匹配括号内的任意字符 [^…] 匹配括号内不包含的任意字符，和 […] 是相反的1select 'ourstring' regexp 'regular expr' 具体见 https://www.cnblogs.com/cxuanBlog/p/14328628.html group by + with roll up: 增加总结行https://blog.csdn.net/guo_ridgepole/article/details/81609810https://blog.csdn.net/qq_42254088/article/details/81904819123456select sex, count(*) as tot from user group by sex每个性别一条记录，总共两条记录select sex, count(*) as tot from user group by sex with roll up会多一个总人数select sex, count(*) as tot from user group by sex, dep with roll up除了总人数，每个sex会有一个总人数，比没有roll up多三条记录 外键问题InnoDB 存储引擎是支持外键的，而 MyISAM 存储引擎是不支持外键的，因此在 MyISAM 中设置外键会不起作用。 表名大小写问题见 https://www.cnblogs.com/cxuanBlog/p/14328628.html mysql 进阶 存储引擎MySQL 默认支持多种存储引擎，来适用不同数据库应用，用户可以根据需要选择合适的存储引擎，下面是 MySQL 支持的存储引擎MyISAM, InnoDB, BDB, MEMORY, MERGE, EXAMPLE, NDB Cluster, ARCHIVE, CSV, BLACKHOLE, FEDERATED默认情况下，如果创建表不指定存储引擎，会使用默认的存储引擎，如果要修改默认的存储引擎，那么就可以在参数文件中设置 default-table-type。show engines 可以查询当前数据库支持的存储引擎在创建新表的时候，可以通过增加ENGINE关键字来设置新建表的存储引擎，create table new(id int(10), name varchar(20)) engine = MyISAM如果不知道已有表的存储引擎，可以使用show create table tbname来查看如果想要更换引擎，可以使用alter table tbname engine = myisam; 一些存储引擎的特点 MyISAM在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM 并发性比较差，使用的场景比较少，主要特点是 不支持事务操作，ACID 的特性也就不存在了，这一设计是为了性能和效率考虑的。 不支持外键操作，如果强行增加外键，MySQL 不会报错，只不过外键不起作用。 MyISAM 默认的锁粒度是表级锁，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。 MyISAM 会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是 .frm(存储表定义)、.MYD(MYData,存储数据)、MYI(MyIndex,存储索引)。这里需要特别注意的是 MyISAM 只缓存索引文件，并不缓存数据文件。 MyISAM 支持的索引类型有 全局索引(Full-Text)、B-Tree 索引、R-Tree 索引 Full-Text 索引：它的出现是为了解决针对文本的模糊查询效率较低的问题。 B-Tree 索引：所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点 R-Tree索引：它的存储方式和 B-Tree 索引有一些区别，主要设计用于存储空间和多维数据的字段做索引,目前的 MySQL 版本仅支持 geometry 类型的字段作索引，相对于 BTREE，RTREE 的优势在于范围查找。 数据库所在主机如果宕机，MyISAM 的数据文件容易损坏，而且难以恢复。 增删改查性能方面：SELECT 性能较高，适用于查询较多的情况 InnoDB自从 MySQL 5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于 MyISAM，InnoDB 存储引擎有了较大的改变，它的主要特点是 支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是可重复读(repetable-read)、通过MVCC（并发版本控制）来实现的。能够解决脏读和不可重复读的问题。 InnoDB 支持外键操作。 InnoDB 默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。 和 MyISAM 一样的是，InnoDB 存储引擎也有 .frm文件存储表结构 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。 InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。 InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。 增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。 MEMORYMEMORY 存储引擎使用存在内存中的内容来创建表。每个 MEMORY 表实际只对应一个磁盘文件，格式是 .frm。MEMORY 类型的表访问速度很快，因为其数据是存放在内存中。默认使用 HASH 索引。 MERGEMERGE 存储引擎是一组 MyISAM 表的组合，MERGE 表本身没有数据，对 MERGE 类型的表进行查询、更新、删除的操作，实际上是对内部的 MyISAM 表进行的。MERGE 表在磁盘上保留两个文件，一个是 .frm 文件存储表定义、一个是 .MRG 文件存储 MERGE 表的组成等。 合适引擎的选择在实际开发过程中，我们往往会根据应用特点选择合适的存储引擎。 MyISAM：如果应用程序通常以检索为主，只有少量的插入、更新和删除操作，并且对事物的完整性、并发程度不是很高的话，通常建议选择 MyISAM 存储引擎。 InnoDB：如果使用到外键、需要并发程度较高，数据一致性要求较高，那么通常选择 InnoDB 引擎，一般互联网大厂对并发和数据完整性要求较高，所以一般都使用 InnoDB 存储引擎。 MEMORY：MEMORY 存储引擎将所有数据保存在内存中，在需要快速定位下能够提供及其迅速的访问。MEMORY 通常用于更新不太频繁的小表，用于快速访问取得结果。 MERGE：MERGE 的内部是使用 MyISAM 表，MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善 MERGE 表的访问效率 合适数据类型的选择见 https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247495882&amp;idx=1&amp;sn=488a147b3bf3c710806ce7031e6186b5&amp;chksm=c04ae794f73d6e829f59b76657db17c50daab3633cc488629efbf05b675209a23ff96bab9f90&amp;scene=21#wechat_redirect 索引所有的 MySQL 类型都可以进行索引，对相关列使用索引是提高 SELECT 查询性能的最佳途径。MyISAM 和 InnoDB 都是使用 BTREE 作为索引，MySQL 5 不支持函数索引，但是支持 前缀索引。前缀索引顾名思义就是对列字段的前缀做索引，前缀索引的长度和存储引擎有关系。MyISAM 前缀索引的长度支持到 1000 字节，InnoDB 前缀索引的长度支持到 767 字节，索引值重复性越低，查询效率也就越高。在 MySQL 中，主要有下面这几种索引 全局索引(FULLTEXT)：全局索引，目前只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题，并且只限于 CHAR、VARCHAR 和 TEXT 列。 哈希索引(HASH)：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。默认情况下，MEMORY 存储引擎使用 HASH 索引，但也支持 BTREE 索引。 B-Tree 索引：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。 R-Tree 索引：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。索引可以在创建表的时候进行创建，也可以单独创建，下面我们采用单独创建的方式，我们在 test 上创建前缀索引, create index varchar_index on tbname(id)删除索引，drop index varchar_index on tbname 索引设计原则创建索引的时候，要尽量考虑以下原则，便于提升索引的使用效率。 选择索引位置，选择索引最合适的位置是出现在 where 语句中的列，而不是 select 关键字后的选择列表中的列。 选择使用唯一索引，顾名思义，唯一索引的值是唯一的，可以更快速的确定某条记录，例如学生的学号就适合使用唯一性索引，而学生的性别则不适合使用，因为不管搜索哪个值，都差不多有一半的行。 为经常使用的字段建立索引，如果某个字段经常用作查询条件，那么这个字段的查询速度在极大程度上影响整个表的查询速度，因此为这样的字段建立索引，可以提高整个表的查询速度。 不要过度索引，限制索引数目，索引的数目不是越多越好，每个索引都会占据磁盘空间，索引越多，需要的磁盘空间就越大。 尽量使用前缀索引，如果索引的值很长，那么查询速度会受到影响，这个时候应该使用前缀索引，对列的某几个字符进行索引，可以提高检索效率。 利用最左前缀，在创建一个 n 列的索引时，实际上是创建了 MySQL 可利用的 n 个索引。多列索引可以起到几个索引的作用，利用索引最左边的列来匹配行，这样的列称为最左前缀。 对于使用 InnoDB 存储引擎的表来说，记录会按照一定的顺序保存。如果有明确的主键定义，那么会按照主键的顺序进行保存；如果没有主键，但是有唯一索引，那么就按照唯一索引的顺序进行保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序进行保存。一般来说，使用主键的顺序是最快的 删除不再使用或者很少使用的索引 视图的基本操作视图的英文名称是 view，它是一种虚拟存在的表。视图对于用户来说是透明的，它并不在数据库中实际存在，视图是使用数据库行和列动态组成的表。视图相对于普通的表来说，优势包含下面这几项 使用视图可以简化操作：使用视图我们不用关注表结构的定义，我们可以把经常使用的数据集合定义成视图，这样能够简化操作。 安全性：用户对视图不可以随意的更改和删除，可以保证数据的安全性。 数据独立性：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响， 数据库表增加列对视图没有影响；具有一定的独立性 操作 语句 创建视图 create view viewname as (select …) 查看视图信息 show tables 删除视图 drop view viewname 查看表结构 describe viewname 更新视图 update viewname set … 存储过程和函数「存储过程是在数据库系统中完成一组特定功能的 SQL 语句集」，它存储在数据库系统中，一次编译后永久有效。 使用存储过程具有可封装性，能够隐藏复杂的 SQL 逻辑。 存储过程可以接收参数，并返回结果 存储过程性能非常高，一般用于批量执行语句 使用存储过程有什么缺点？ 存储过程编写复杂 存储过程对数据库的依赖性比较强，可移植性比较差 在认识到存储过程是什么之后，我们就来使用一下存储过程，这里需要先了解一个小技巧，也就是 delimiter 的用法，delimiter 用于自定义结束符默认;为结束符，通过delimiter $$，可以将结束符定义为$$建立存储过程： 12345delimiter $$create procedure sp_product()beginselect * from product;end $$ 用call调用该过程，call sp_product$$ 存储过程可以接受参数，建立一个带有参数的存储过程 12345delimiter $$create procedure sp_product(in piid int)beginselect * from product where id = pid;end $$ 调用 call sp_product(2)$$ 等价于 select * from product where id=2;存储过程删除 drop procedure sp_product存储过程查看 show create procedure procname 变量级别更详细的解释见 https://www.modb.pro/db/12232首先MySQL服务器启动时会使用其软件内置的变量（俗称写死在代码中的）和配置文件中的变量（如果允许，是可以覆盖源代码中的默认值的）来初始化整个MySQL服务器的运行环境，这些变量通常就是我们所说的全局变量，这些在内存中的全局变量有些是可以修改的。当有客户端连接到MySQL服务器的时候，MySQL服务器会将这些全局变量的大部分复制一份作为这个连接客户端的会话变量，这些会话变量与客户端连接绑定，连接的客户端可以修改其中允许修改的变量，但是当连接断开时这些会话变量全部消失，重新连接时会从全局变量中重新复制一份。其实与连接相关的变量不只有会话变量一种，用户变量也是这样的，用户变量其实就是用户自定义变量，当客户端连接上MySQL服务器之后就可以自己定义一些变量，这些变量在整个连接过程中有效，当连接断开时，这些用户变量消失。局部变量实际上最好理解，通常由DECLARE 关键字来定义，经常出现在存储过程中，非常类似于C和C++函数中的局部变量，而存储过程的参数也和这种变量非常相似，基本上可以作为同一种变量来对待。 变量类别 要点 用户变量 用户变量是基于会话变量实现的，可以暂存，用户变量与连接有关，也就是说一个客户端定义的变量不能被其他客户端使用看到。当客户端退出时，链接会自动释放。我们可以使用 set 语句设置一个变量set @myid = 'xxx'，然后查询我们刚刚设置的用户变量select @myid; 用户变量是和客户端有关系，当我们退出后，这个变量会自动消失，现在我们退出客户端,当我们重新登陆客户端，再次使用 select 条件查询时，发现这个变量已经自动消失了 会话变量 服务器会为每个连接的客户端维护一个会话变量。可以使用show session vaiables;来显示所有会话变量，用set session auto_increment_increment=1;或者set @@session.auto_increment_increment=2;或者set local auto_increment_increment=1;手动设置会话变量，查询会话变量使用select@@session.auto_increment_increment;或者select @@auto_increment_increment;或者select @@local.auto_increment_increment，查询所有的会话变量 show session variables (like '%sql'') 局部变量 MySQL 中的局部变量与 Java 很类似 ，Java 中的局部变量是 Java 所在的方法或者代码块，而 MySQL 中的局部变量作用域是所在的存储过程。MySQL 局部变量使用 declare 来声明。查询可使用select，declare count int(4);select count;,也可以使用select into 来设置值select count(id) into count from items where price &lt; 99; 全局变量 当服务启动时，它将所有全局变量初始化为默认值，其作用域为server的整个生命周期。用show global variables;来查看全局变量，用set global sql_warning=ON;或者set @@global.sql_warning=OFF;，查询全局变量，则可以使用select @@global.sql_warnings;或者show global variables like '%sql_warnings%', 查询所有的全局变量 show global variables (like '%sql'') select@@变量名这种形式默认取的是会话变量，如果查询的会话变量不存在就会获取全局变量，比如@@max_connections 但是SET操作的时候，set @@变量名=xxx 总是操作的会话变量，如果会话变量不存在就会报错 触发器 Trigger触发器一般作用在表上，在满足定义条件时触发，并执行触发器中定义的语句集合，下面我们就来一起认识一下触发器。举个例子来认识一下触发器：比如你有一个日志表和金额表，你每录入一笔金额就要进行日志表的记录，你会怎么样？同时在金额表和日志表插入数据吗？如果有了触发器，你可以直接在金额表录入数据，日志表会自动插入一条日志记录，当然，触发器不仅只有新增操作，还有更新和删除操作。 触发器的创建1create trigger triggername triggertime triggerevent on tbname for each row triggerstmt triggername：这个指的就是触发器的名字 triggertime：这个指的就是触发器触发时机，是 BEFORE 还是 AFTER triggerevent: 这个指的就是触发器触发事件，一共有三种事件：「INSERT、UPDATE 或者 DELETE」。 tbname：这个参数指的是触发器创建的表名，在哪个表上创建 triggerstmt: 触发器的程序体，也就是 SQL 语句所以，可以创建六种触发器「BEFORE INSERT、AFTER INSERT、BEFORE UPDATE、AFTER UPDATE、BEFORE DELETE、AFTER DELETE」, 上面的 for each now 表示任何一条记录上的操作都会触发触发器。 删除触发器：drop triggger tgname 查看触发器的状态：show triggers or 查询information_schema.triggers 触发器的限制：触发程序不能调用将数据返回客户端的存储程序。也不能使用 CALL 语句的动态 SQL 语句。不能在触发器中开始和结束语句，例如 START TRANSACTION example已有一个product表，希望每次product有新加入的行，相应的在product_info表中加入行1234567create table product_info(pinfo varchar(20)); #建表# 创建triggercreate trigger tg_infoafter insert on product for each rowbegininsert into product_info values('insert after inserting into product')end $$ Reference: https://www.cnblogs.com/cxuanBlog/p/13173547.html https://www.cnblogs.com/cxuanBlog/p/14328628.html https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247495882&amp;idx=1&amp;sn=488a147b3bf3c710806ce7031e6186b5&amp;chksm=c04ae794f73d6e829f59b76657db17c50daab3633cc488629efbf05b675209a23ff96bab9f90&amp;scene=21#wechat_redirect","link":"/2021/09/10/sql-improvement-3/"},{"title":"SQL调优实践","text":"还记得之前做的docker部署flask的项目，好久不看，发现云上mysql已经存下了爬下来好多微博数据。之前的建表非常简单，几乎没有去考虑加索引去优化，随着数据越来越多，问题逐渐暴露出来。正好最近也在学习sql调优的知识，是个不错的练习机会。Let’s do this！ 如何通过索引调优sql，在前面的文章中已经设计了，在本篇中里我们首先based on 程序员cxuan的这篇文章做一些其他方面调优的总结。 通过 show status 命令了解SQL执行次数show status 命令会显示每个服务器变量 variable_name 和 value，状态变量是只读的。如果使用 SQL 命令，可以使用 like 或者 where 条件来限制结果。like 可以对变量名做标准模式匹配, show status like 'Com_%'。 Com_xxx 表示的是每个 xxx 语句执行的次数，我们通常关心的是 select 、insert 、update、delete 语句的执行次数，即 Com_select：执行 select 操作的次数，一次查询会使结果 + 1。 Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。 Com_update：执行 UPDATE 操作的次数。 Com_delete：执行 DELETE 操作的次数。 以 Innodb_ 为开头的参数主要有 Innodb_rows_read：执行 select 查询返回的行数。 Innodb_rows_inserted：执行 INSERT 操作插入的行数。 Innodb_rows_updated：执行 UPDATE 操作更新的行数。 Innodb_rows_deleted：执行 DELETE 操作删除的行数。 通过上面这些参数执行结果的统计，我们能够大致了解到当前数据库是以更新（包括插入、删除）为主还是查询为主。除此之外，还有一些其他参数用于了解数据库的基本情况。 Connections：查询 MySQL 数据库的连接次数，这个次数是不管连接是否成功都算上。 Uptime：服务器的工作时间。 Slow_queries：满查询次数。 Threads_connected：查看当前打开的连接的数量。 下面这个博客汇总了几乎所有 show status 的参数，可以当作参考手册。https://blog.csdn.net/ayay_870621/article/details/88633092 查看线程show processlist，具体解读见cxuan命令详解见 https://blog.csdn.net/weixin_34357436/article/details/91768402 索引详情见cxuan 查看索引的使用情况在 MySQL 索引的使用过程中，有一个 Handler_read_key 值，这个值表示了某一行被索引值读的次数。 Handler_read_key 的值比较低的话，则表明增加索引得到的性能改善不是很理想，可能索引使用的频率不高。还有一个值是 Handler_read_rnd_next，这个值高则意味着查询运行效率不高，应该建立索引来进行抢救。这个值的含义是在数据文件中读下一行的请求数。如果正在进行大量的表扫描，Handler_read_rnd_next 的值比较高，就说明表索引不正确或写入的查询没有利用索引。 正式开始解决问题当前hotsearch表的结构如下 12345678910CREATE TABLE `hotsearch` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `topic` varchar(50) NOT NULL, `entry_time` datetime NOT NULL, `last_update` datetime NOT NULL, `peak_rank` int(11) NOT NULL, `peak_read` int(11) NOT NULL, `cover_cnt` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=7465 DEFAULT CHARSET=utf8 id没有必要使用bigint(20)，且peak_rank和cover_cnt也没有必要使用int(11)，在初始设计上，这些就占用了太多的空间 所有可能的用到的sql语句都在db.py当中，我们简单的整理一下对于新抓取的数据 12345678910111213#1select topic from hotsearch where DATE(last_update)=CURDATE() or DATE(last_update)=CURRENT_DATE()-1#2insert into hotsearch(topic, entry_time, last_update, peak_rank, peak_read, cover_cnt)values(%s,%s,%s,%s,%s,%s)\"#3update hotsearch set last_update= %s, peak_rank=CASE when peak_rank &lt; %s then peak_rank else %s END, peak_read=CASE when peak_read &gt; %s then peak_read else %s END, cover_cnt = cover_cnt+1 WHERE topic = %s update操作，如果在topic上有所有可能会加快select操作即使在last_update上建立索引，也会因为DATE函数和or导致索引失效，用explain检测发现确实如此，type为ALL表示全表搜索 取得基本数据 12345678#4sql1 = \"select count(*) from weibo.hotsearch\"#5sql2 = \"select count(*) from hotsearch where DATE(entry_time) = CURDATE()\"#6sql3 = \"select last_update from hotsearch order by last_update desc limit 1\"#7sql4 = \"select DATEDIFF( CURDATE(), (select DATE(last_update) from hotsearch order by last_update limit 1))+1\" 直接用max/min来完成6、7的工作 流行话题 123456#8select topic, peak_readfrom hotsearchwhere DATEDIFF(DATE(entry_time),CURDATE())&lt;=30order by peak_read desclimit 10 entry_time上也可以加上索引，同时可以把datadiff的公式transform成curdate-30 词云 123456#9select topic, peak_readfrom hotsearchwhere DATEDIFF(DATE(entry_time),CURDATE())&lt;=30order by peak_read desclimit 50 同上 按标题搜索/按日期搜索 123456789101112#10select topic, peak_read, peak_rank, entry_time, last_updatefrom hotsearchwhere topic like '%keyword%'order by peak_read desc#11select topic, peak_read, peak_rank, entry_time, last_updatefrom hotsearchwhere date(entry_time) &lt;= date(\\'\" + edt + \"\\') anddate(entry_time) &gt;= date(\\'\" + std + \"\\')order by peak_read desc \" 调整表的结构使之更加节省空间 123alter table `hotsearch` modify id INT(8);alter table `hotsearch` modify peak_rank TINYINT;alter table `hotsearch` modify cover_cnt INT(4) 在entry_time和last_update上新建索引 12create index entry_idx on hotsearch(entry_time)create index update_idx on hotsearch(last_update) change #1 to the following，我们用explain会发现type从all变成了range，该查询利用了update_idx这个索引，这里千万不能CURRENT_DATE()-1，比如现在日期是2021-09-01，直接减一会得到20210900 1select * from hotsearch where last_update between date_sub(CURRENT_DATE(), INTERVAL 1 DAY) and CURRENT_DATE() explain #5后发现，该句无需改动，直接可以运用entry_time上的索引entry_idx，查询type为index，index与ALL区别为index类型只遍历索引树，这通常比ALL快，因为索引文件通常比数据文件小，也就是说虽然ALL和Index都是读全表，但Index是从索引中读取的，而ALL都是从磁盘中读的。但是如果改为一下语句，则可以升级为range。 1select count(id) from hotsearch where entry_time &gt;= CURRENT_DATE() #6 改为select max(last_update) from hotsearch , type由index变为NULL #7 改为select DATEDIFF( CURDATE(), (select DATE(min(last_update)) from hotsearch))+1, type由内层index、外层NULL，变为内外均为NULL #8 #9做类似修改","link":"/2021/09/10/sql-improvement-practice/"},{"title":"风格迁移","text":"","link":"/2021/09/12/style-transfer/"},{"title":"SQL的执行顺序","text":"SQL执行顺序是怎么回事呢？SQL相信大家都很熟悉，但是SQL执行顺序是怎么回事呢，下面就让小编带大家一起了解吧。SQL执行顺序，其实就是SQL语句执行的顺序，大家可能会很惊讶SQL怎么会执行顺序呢？但事实就是这样，小编也感到非常惊讶。这就是关于SQL执行顺序的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！ reference：https://juejin.cn/post/6864555988873707527 12345678910(8)SELECT&nbsp;(9)DISTINCT&nbsp;&lt;select_list&gt;(1)FROM&nbsp;&lt;left_table&gt;(3)&lt;join_type&gt;JOIN&nbsp;&lt;right_table&gt;(2)ON&lt;join_condition&gt;(4)WHERE&lt;where_condition&gt;(5)GROUP&nbsp;BY&lt;group_by_list&gt;(6)WITH&nbsp;{CUBE|ROLLUP}(7)HAVING&lt;having_condition&gt;(10)ORDER&nbsp;BY&lt;order_by_list&gt;(11)LIMIT&lt;limit_number&gt; FROM：对FROM子句中的左表和右表执行笛卡儿积（Cartesian product），产生虚拟表VT1ON：对虚拟表VT1应用ON筛选，只有那些符合的行才被插入虚拟表VT2中JOIN：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止WHERE：对虚拟表VT3应用WHERE过滤条件，只有符合的记录才被插入虚拟表VT4中GROUP BY：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5CUBE|ROLLUP：对表VT5进行CUBE或ROLLUP操作，产生表VT6HAVING：对虚拟表VT6应用HAVING过滤器，只有符合的记录才被插入虚拟表VT7中。SELECT：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中DISTINCT：去除重复数据，产生虚拟表VT9ORDER BY：将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10。LIMIT：取出指定行的记录，产生虚拟表VT11，并返回给查询用户 具体详细步骤：https://juejin.cn/post/6864555988873707527","link":"/2021/09/22/sql-sequence/"},{"title":"初学算法：图中的DFS和BFS","text":"以下是leetcode中，我觉得难度适中的几道图上DFS和bBFS的题目，在这里记录下来，以供未来复习之用。","link":"/2021/09/25/DFS-BFS/"},{"title":"初学算法：排序","text":"下面简要罗列一下主要的几种排序方法gif直观表达参见： https://www.cnblogs.com/onepixel/p/7674659.html 随机数生成器12345from random import randintdef generateRandomArray(n, min, max): arr = [] arr = [randint(min, max) for x in range(n)] return arr 是否有序12345def isSorted(alist): for i in range(0, len(alist)-1): if alist[i] &gt; alist[i+1]: return False return True 时间计算12345678910111213#t1 = timeit.Timer('testSort(\"某种排序算法函数\", alist)', 'from __main__ import testSort, 某种排序算法函数, alist')#print('某种排序算法：%s s' %t1.timeit(number=1))# func表示要检测的算法函数，alist为传入的数列def testSort(func, alist): alist = func(alist) assert isSorted(alist), \"排序算法错误\\n\"rand_num=[33,97,66,40,111,14,3,9,93,86,34,102,75]rand_num=generateRandomArray(15, 1, 100)l=len(rand_num)print('Before Sort:',rand_num)print('共有',l,'个数字') 冒泡排序1234567891011121314print('冒泡排序前',rand_num)nums=rand_num[:]def bubbleSort(nums): l=len(nums) for i in range(l-1,-1,-1): swap=False for j in range(1,i+1): if nums[j]&lt;nums[j-1]: nums[j],nums[j-1]=nums[j-1],nums[j] swap=True if not swap: break return numsprint('冒泡排序后',bubbleSort(nums)) 选择排序123456789101112print('选择排序前',rand_num)nums=rand_num[:]def selectionSort(nums): l=len(nums) for i in range(l-1): min_idx=i for j in range(i+1,l): if nums[j]&lt;nums[min_idx]: min_idx=j nums[i],nums[min_idx]=nums[min_idx],nums[i] return numsprint('选择排序后',selectionSort(nums)) 插入排序12345678910111213print('插入排序前',rand_num)nums=rand_num[:]def insertSort(nums): l=len(nums) for i in range(1,l): pos=i curvalue=nums[i] while nums[pos-1]&gt;curvalue and pos&gt;0: nums[pos]=nums[pos-1] pos-=1 nums[pos]=curvalue return numsprint('插入排序后',insertSort(nums)) 希尔排序它以插入排序为基础，将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序，从而实现对插入排序性能的改进。划分子列的特定方法是希尔排序的关键。我们并不是将原始列表分成含有连续元素的子列，而是确定一个划分列表的增量 “i”，这个i更准确地说，是划分的间隔。然后把每间隔为i的所有元素选出来组成子列表，然后对每个子序列进行插入排序，最后当 i=1 时，对整体进行一次直接插入排序。 12345678910111213141516171819202122232425262728print('希尔排序前',rand_num)nums=rand_num[:]# 希尔排序def shellSort(alist): n = len(alist) gap = n // 2 while gap &gt; 0: for i in range(gap): gapInsetionSort(alist, i, gap) gap = gap // 2 return alist# # start子数列开始的起始位置， gap表示间隔def gapInsetionSort(alist,startpos,gap): #希尔排序的辅助函数 #在子序列中做插入排序 for i in range(startpos+gap,len(alist),gap): position=i currentvalue=alist[i] while position&gt;startpos and alist[position-gap]&gt;currentvalue: alist[position]=alist[position-gap] position=position-gap alist[position]=currentvalue #print(i,':',alist)print('希尔排序后',shellSort(nums)) 归并排序12345678910111213141516171819202122232425262728293031print('归并排序前',rand_num)# 自顶向下和自下向顶def mergeSort(seq): \"\"\"归并排序\"\"\" if len(seq) &lt;= 1: return seq mid = len(seq) // 2 # 将列表分成更小的两个列表 # 分别对左右两个列表进行处理，分别返回两个排序好的列表 left = mergeSort(seq[:mid]) right = mergeSort(seq[mid:]) # 对排序好的两个列表合并，产生一个新的排序好的列表 return merge(left, right)def merge(left, right): \"\"\"合并两个已排序好的列表，产生一个新的已排序好的列表\"\"\" result = [] # 新的已排序好的列表 i = 0 # 下标 j = 0 # 对两个列表中的元素 两两对比。 # 将最小的元素，放到result中，并对当前列表下标加1 while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return resultprint('归并排序后',mergeSort(nums)) 快排参考： http://data.biancheng.net/view/117.html https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html 123456789101112131415161718192021print('快排前',rand_num)def quickSort(lists,i,j): if i &gt;= j: return list pivot = lists[i] low = i high = j while i &lt; j: while i &lt; j and lists[j] &gt;= pivot: j -= 1 while i &lt; j and lists[i] &lt;=pivot: i += 1 lists[j],lists[i] = lists[i],lists[j] lists[j] = pivot quickSort(lists,low,i-1) quickSort(lists,i+1,high) return listsprint('快排后',quickSort(nums,0,len(nums)-1)) 堆排序123456789101112131415161718192021222324252627282930313233343536373839print('堆排序前',rand_num)# several mode to choose from:def maxHeapfy(alist, length, parent): left = 2 * parent + 1 right = 2 * parent + 2 largest = parent if left &lt; length and alist[left] &gt; alist[largest]: largest = left if right &lt; length and alist[right] &gt; alist[largest]: largest = right if largest != parent: alist[largest], alist[parent] = alist[parent], alist[largest] maxHeapfy(alist, length, largest) # 递归构建def buildMaxHeap(alist): # 构建最大堆 n = len(alist) lastParent = (n-1) // 2 for i in range(lastParent, -1, -1): maxHeapfy(alist, n, i)def heapSort(alist): buildMaxHeap(alist) n = len(alist) for i in range(n-1, -1, -1): alist[0], alist[i] = alist[i], alist[0] # 将最大值放在最后面 maxHeapfy(alist, i, 0) return alistprint('堆排序后',heapSort(nums)) 计数排序计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 123456789101112131415print('计数排序前',rand_num)from collections import defaultdictdef countSort(nums): d = defaultdict(int) l = len(nums) for i in nums: d[i] += 1 out = [] for j in sorted(d): for n in range(d[j]): out.append(j) return outprint('计数排序后',countSort(nums), isSorted(countSort(nums))) 桶排序1234print('桶排序前',rand_num)def bucketSort(nums): l=len(nums)print('桶排序后',bucketSort(nums)) Visualization 10 20 50 100 200 500 1000 10000 20000 50000 1000000 numbers run each algo for 10 times and take its mean","link":"/2021/09/25/Sorting/"},{"title":"初学算法：二分法查找","text":"二分查找参考: https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html 以下是leetcode中，我觉得难度适中的几道关于二分查找的题目，在这里记录下来，以供未来复习之用。 EASY:Leetcode: 69 Sqrt(x) 【找下界】Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5. 1234567891011121314151617181920212223242526class Solution: def mySqrt(self, x: int) -&gt; int: if x==1: return 1 elif x==0: return 0 low = 1 high = x//2+1 mid = (low + high)//2 while low &lt; high: if mid**2 &gt; x: high = mid - 1 elif mid**2 &lt; x: low = mid elif mid**2 == x: return mid mid = (low + high + 1)//2 return mid 下届寻找基本与上届相同，需要注意的是在取中间索引时，使用了向上取整。若同之前一样使用向下取整，那么当low == high-1，而array[low] 又小于 target时就会形成死循环。因为low无法往上爬超过high。 Leetcode: 278 First Bad Version 【确定的下界】You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. 12345678910111213141516171819202122232425# The isBadVersion API is already defined for you.# @param version, an integer# @return an integer# def isBadVersion(version):class Solution: def firstBadVersion(self, n): \"\"\" :type n: int :rtype: int \"\"\" low = 1 high = n mid = (low + high)//2 while low&lt;high: if isBadVersion(mid): high = mid else: low = mid + 1 mid = (low + high)//2 return mid Leetcode: 704 Binary Search 【找一个确切的数】Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. =&gt; 二分法 12345678910111213141516class Solution: def search(self, nums: List[int], target: int) -&gt; int: l = len(nums) low = 0 high = l-1 mid = (low + high) // 2 while low &lt;= high: if nums[mid] == target: return mid elif nums[mid] &lt; target: low = mid + 1 elif nums[mid] &gt; target: high = mid - 1 mid = (low + high) // 2 return -1 注意low&lt;=high这里的等号。 Leetcode: 1539 Kth Missing Positive Number聪明的解法：https://leetcode.com/problems/kth-missing-positive-number/solution/ Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this arra Brute Force (Time O(N) Space O(1)) 1234567891011121314151617181920class Solution: def findKthPositive(self, arr: List[int], k: int) -&gt; int: # if the kth missing is less than arr[0] if k &lt;= arr[0] - 1: return k k -= arr[0] - 1 # search kth missing between the array numbers for i in range(len(arr) - 1): # missing between arr[i] and arr[i + 1] curr_missing = arr[i + 1] - arr[i] - 1 # if the kth missing is between # arr[i] and arr[i + 1] -&gt; return it if k &lt;= curr_missing: return arr[i] + k # otherwise, proceed further k -= curr_missing # if the missing number if greater than arr[-1] return arr[-1] + k Binary Search (Time O(logN) Space O(1)) 12345678910111213141516171819202122class Solution: def findKthPositive(self, arr: List[int], k: int) -&gt; int: left, right = 0, len(arr) - 1 while left &lt;= right: pivot = (left + right) // 2 # If number of positive integers # which are missing before arr[pivot] # is less than k --&gt; # continue to search on the right. if arr[pivot] - pivot - 1 &lt; k: left = pivot + 1 # Otherwise, go left. else: right = pivot - 1 # At the end of the loop, left = right + 1, # and the kth missing is in-between arr[right] and arr[left]. # The number of integers missing before arr[right] is # arr[right] - right - 1 --&gt; # the number to return is # arr[right] + k - (arr[right] - right - 1) = k + left return left + k 如果不能理解为什么return left + k， 请看评论区jz2233的解释： 123456the current number is arr[right](arr[right] - right - 1) number of element are missing before arr[right]we want to find the kth missing elementsince the kth missing element lies between right pointer and left pointer( right + 1 )so k- ( arr[right] -right -1) is the number of elements we need to find after arr[right] and before arr[left]since the numbers should have been consecutive if not missing, the element is just going to be arr[right] plus the number of missing elements that we have to find after arr[right]. MEDIUMLeetcode: 33 Search in Rotated Sorted Array 【在轮转后的有序数组上应用二分查找法】There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. 12345678910111213141516171819202122232425262728293031class Solution: def search(self, nums: List[int], target: int) -&gt; int: low = 0 high = len(nums)-1 while low &lt;= high: mid = (low + high)//2 if nums[mid] &lt; target: if nums[mid] &gt; nums[low]: low = mid + 1 else: if nums[high] &lt; target: high = mid - 1 else: low = mid + 1 elif nums[mid] &gt; target: if nums[high] &gt; nums[mid]: high = mid - 1 else: if nums[low] &gt; target: low = mid + 1 else: high = mid -1 else: return mid return -1 Leetcode: 287 Find the Duplicate NumberGiven an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. Sort 123456class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: nums.sort() for i in range(1, len(nums)): if nums[i] == nums[i-1]: return nums[i] Set 1234567class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: seen = set() for num in nums: if num in seen: return num seen.add(num) Negative Marking (Time O(n) Space O(1))Note: This approach temporarily modifies individual elements and thus does not satisfy the problem constraints. However, this approach is intuitive and utilizes a technique that is useful to know. Furthermore, the underlying concept lends itself to solving similar problems. As such, you can further practice this technique on other problems such as 41. First Missing Positive. IntuitionThere are n + 1n+1 positive numbers in the array (nums) (all in the range [1, n]). Since the array only contains positive integers, we can track each number (numnum) that has been seen before by flipping the sign of the number located at index |num|, where || denotes absolute value.For example, if the input array is [1, 3, 3, 2], then for 11, flip the number at index 11, making the array [1,-3,3,2]. Next, for −3 flip the number at index 33, making the array [1,-3,3,-2]. Finally, when we reach the second 33, we’ll notice that nums[3] is already negative, indicating that 33 has been seen before and hence is the duplicate number. 1234567891011121314class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: for num in nums: cur = abs(num) if nums[cur] &lt; 0: duplicate = cur break nums[cur] = -nums[cur] # Restore numbers for i in range(len(nums)): nums[i] = abs(nums[i]) return duplicate Binary Search (Time O(nlogn) Space O(1)) Consider an array that has nn distinct numbers in the range [1,n]. For example: [1,2,3,4,5]. If we pick any one of these 5 numbers and count how many numbers are less than or equal to it, the answer will be equal to that number. So in [1,2,3,4,5], if you pick the number 4, there’s exactly 4 numbers that are less than or equal to 4. If you pick 3, there’s exactly 3 numbers that are less than or equal to 33, and so on. However, when you have duplicates in the array, this count will exceed the number at some point. For example: in [4,3,4,5,2,4,1], 3 has 3 numbers less than or equal to it. However, the duplicate number will have a count of numbers less than or equal to itself, that is greater than itself (in this example, 44, which is the duplicate, has 6 numbers that are less than or equal to it). Hence, the smallest number that satisfies this property is the duplicate number. Consider an example: [4,6,4,2,1,4,3,5]. This has n + 1 elements where nn = 7. Take each number from 1 to 7 and count how many numbers are less than or equal to it. In our example, count(1,2,3,4,5,6,7) = (1,2,3,6,7,8,8). If we performed a linear scan, we would find that the number 44 is the first number to have its counts exceed the actual number (i.e. 6 &gt; 4) - hence 44 is the duplicate. A linear scan based approach would require an overall O(n^2) time complexity in the worst case, since we’d need to iterate over each of the nn numbers (requiring O(n) time), and then compare it to every element to generate a count of equal or lower numbers (requiring O(n) time as well - nested inside the other O(n) loop). Fortunately, count is monotonic (it’s values are always in non-decreasing order), and hence it is an excellent candidate for binary search. In the binary search approach, instead of doing a linear scan from 1 to n, we can apply a binary search with a goal of finding the smallest number that satisfies the aforementioned property. We start with a search space of [1,n] that has a midpoint midmid. If mid satisfies the property, we narrow our search space to the left half [1, mid - 1] and continue searching, otherwise, we narrow our search space to the right half [mid + 1, n].12345678910111213141516171819class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: # 'low' and 'high' represent the range of values of the target low = 1 high = len(nums) - 1 while low &lt;= high: cur = (low + high) // 2 count = 0 # Count how many numbers are less than or equal to 'cur' count = sum(num &lt;= cur for num in nums) if count &gt; cur: duplicate = cur high = cur - 1 else: low = cur + 1 return duplicate Leetcode: 718 Maximum Length of Repeated SubarrayGiven two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays. Example 1: 123Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]Output: 3Explanation: The repeated subarray with maximum length is [3,2,1]. Example 2: 12Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]Output: 5 Binary Search with naive check 1234567891011121314151617class Solution(object): def findLength(self, A, B): def check(length): seen = set(tuple(A[i:i+length]) for i in range(len(A) - length + 1)) return any(tuple(B[j:j+length]) in seen for j in range(len(B) - length + 1)) lo, hi = 0, min(len(A), len(B)) + 1 while lo &lt; hi: mi = (lo + hi) // 2 if check(mi): lo = mi + 1 else: hi = mi return lo - 1 DP (Time O(MN) Space O(MN))Since a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know dp[i][j] = dp[i+1][j+1] + 1. Also, the answer is max(dp[i][j]) over all i, j. We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in dp for any larger i, j. 123456789class Solution(object): def findLength(self, A, B): memo = [[0] * (len(B) + 1) for _ in range(len(A) + 1)] for i in range(len(A) - 1, -1, -1): for j in range(len(B) - 1, -1, -1): if A[i] == B[j]: memo[i][j] = memo[i + 1][j + 1] + 1 return max(max(row) for row in memo)","link":"/2021/09/25/binary-search/"},{"title":"初学算法：树 (DFS、BFS、二分查找树)","text":"以下是leetcode中，我觉得难度适中的几道关于树的题目，在这里记录下来，以供未来复习之用。","link":"/2021/09/25/tree/"},{"title":"初学算法：排序题目","text":"下面简要罗列一下关于排序的题目 977. Squares of a Sorted ArrayGiven an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. sort (Time Complexity O(NlogN); Space Complexity O(N)) 123class Solution(object): def sortedSquares(self, A): return sorted(x*x for x in A) Two Pointer (Time Complexity O(N); Space Complexity O(N)) 12345678910111213141516171819class Solution: def sortedSquares(self, nums: List[int]) -&gt; List[int]: l = len(nums) result = l*[0] left = 0 right = l-1 for i in range(l-1, -1, -1): if abs(nums[left]) &gt; abs(nums[right]): sq = nums[left] left += 1 else: sq = nums[right] right -= 1 result[i] = sq * sq return result 905. Sort Array By ParityGiven an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. 奇数和偶数内部不需要排序。Return any array that satisfies this condition. just sort (Time Complexity O(NlogN); Space Complexity O(N)) 1234class Solution(object): def sortArrayByParity(self, A): A.sort(key = lambda x: x % 2) return A Two pass (Time Complexity O(N); Space Complexity O(N)) 1234class Solution(object): def sortArrayByParity(self, A): return ([x for x in A if x % 2 == 0] + [x for x in A if x % 2 == 1]) quickSort (in-place) Intuition If we want to do the sort in-place, we can use quicksort, a standard textbook algorithm. Algorithm We’ll maintain two pointers i and j. The loop invariant is everything below i has parity 0 (ie. A[k] % 2 == 0 when k &lt; i), and everything above j has parity 1. Then, there are 4 cases for (A[i] % 2, A[j] % 2): If it is (0, 1), then everything is correct: i++ and j–. If it is (1, 0), we swap them so they are correct, then continue. If it is (0, 0), only the i place is correct, so we i++ and continue. If it is (1, 1), only the j place is correct, so we j– and continue. Throughout all 4 cases, the loop invariant is maintained, and j-i is getting smaller. So eventually we will be done with the array sorted as desired. 1234567891011class Solution(object): def sortArrayByParity(self, A): i, j = 0, len(A) - 1 while i &lt; j: if A[i] % 2 &gt; A[j] % 2: A[i], A[j] = A[j], A[i] if A[i] % 2 == 0: i += 1 if A[j] % 2 == 1: j -= 1 return A","link":"/2021/09/25/sort-prob/"},{"title":"卓有成效的管理者","text":"纯粹读书笔记 对管理者的有效性而言，最重要的人物，往往不是管理者直接控制的下属，而是其他部门的人，即所谓的“旁系人士”，或是管理者本人的上司。一位管理者如果不能与这些人主动接触，不能使这些人利用他的贡献，他本身就没有有效性可言。 在组织的内部，不会有成果出现，一切成果都存在于组织之外。 管理者在组织中的地位越高，他的注意力就越容易为内部的问题和挑战所困，而不能看到外部的情况。 世上并无所谓的“有效的个性”，人人都具有做好该做的事情的能力。 作为一个卓有成效的管理者，必须在思想上养成如下五种习惯： 卓有成效的管理者必须懂得如何有效地利用他们的时间。他们会利用自己所能控制的点点滴滴时间开展有条不紊的工作。 卓有成效的管理者重视对外界的贡献。他们不满足于埋头工作，比较注意如何使自己的努力产生必要的成果。他们一接手工作，不是立刻一头钻进上作里去，也不是马上考虑工作的办法和手段，而是首先白问道：”别人希望我做出什么样的成果来？” 卓有成效的管理者善于利用长处，不光善于利用他们自己的长处，而旦也知道如何利用上司、同事及下属的长处。他们还善于抓住形势提供的机会做他们想做的事。他们不会把工作建立在自己的短处相弱点上面，也决不会去做自己做不了的事情。 卓有成效的管理者知道如何将自己的精力集中在少数重要的领域里。在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急，制订出先后次序，重要的事先做，不重要的事放一放，除此之外也没有别的办法，不这么做必然会一事无成。 .最后，卓有成效的管理者善于做出有效的决策。他们知道，要这样做首先要解决条理和秩序问题，也就是如何按正确的次序采取正确的步骤。他们也知道，有效的决策总是在不同意见讨论的基础上作出的一种判断，它决不会是”大家意见一致”的产物。他们认为在很短的时间内作出很多的决策，就难免会出现错误。机构真正需要的只是数量不多的决策，但它们却是些根本性的决策。组织真正需要的是正确的战略，而不是令人眼花缭乱的战术。 时间也是最特殊的一项资源。在其他各项主要资源中，资金实际上是相当充裕的。我们在很久以前就已经了解到，制约经济增长和经济活动的，并不是资金的供给不足，而是对紫荆的需求不大。另外一个限制因素是人力，但总还是可以雇到人才，尽管要雇用到足够优秀的人才并不容易。只有时间，是我们租不到、借不到、也买不到的。 做任何事情都少不了时间，时间是必须具备的一个条件。任何工作都是在时间中进行的，都需要好用时间。但是对这项最特殊的、无可替代和不可或缺的资源，绝大多数人却以为可以取用不竭。有效的管理者与其他人最大的区别，就是他们非常珍惜自己的时间。 一起工作的人越多，工作者用于彼此协调关系的时间肯定越多，而真正用于工作的时间就越少了。因此大型组织只有在大量耗用其管理者的事件后，才能变得强大有力。组织规模越大，管理者实际可掌握的时间越少。 授权，应该是把可以由别人做的事情交付给别人，这样才能真正有自己做的事。 减少无谓的工作，绝对无损于有效性。 时间管理的最后一步，应该是将可由管理者自行支配的零碎时间集中起来。 一般机构对成效的要求往往表现在以下三个方面：直接成果；树立新的价值观及对这些价值观的重新确认；培养与开发明天所需的人才。 管理者失败的常见原因，是他本人出任一项新职位时，不能或不愿为适应新职位的需要而改变。 个人能否有所发展，在很大程度上要看你是否重视贡献。“我对组织能有什么最大的贡献？”，“我需要怎样的自我发展，应该学习什么知识和技能，才能有助于我对组织做出贡献?”，“我应该将我的哪些优点用在我的工作上？”，“我应该为自己设定怎样的标准”。 卓有成效的管理者知道他们能从会议中得到什么，也知道会议的目的是什么或者应该是什么。他坚持开会必须有真正的贡献。 你可以主持会议，听取重要的发言，也可以是与大家共同讨论。但你不能既主持会议，有高谈阔论。 不问“他能和我合得来吗”，要问“他贡献了什么”，不问“他不能做些什么”，而要问“他能做些什么”。所以在用人时，他们用的都是在某方面有所长的人，而不是在各方面都过得去的人。 这个人能够做什么，才是组织器重他的原因。而他不能做什么，则仅是他的限制，仅此而已。 卓有成效的管理者不会设计一个不可能达成的职位。如果一个职位，要有特殊气质的人才能担任，这便注定了是不可能胜任的职位。职位的要求要严格，而涵盖要广，才能使人在情况有所变化时能适应新的需要。知识工作者职位的设计，还应该使人及早发现自己是否适合该岗位。 凡是最能充分发挥期长处且最受到挑战的人，他的工作肯定最起劲，也肯定能最有成就。","link":"/2021/10/12/leadership/"},{"title":"Missing Visit可视化","text":"初步构想：用甘特图把每个病人的visit情况显示出来，横轴为scheduled visit，纵轴为patient ID。这样能够比较容易的看出，每个病人治疗计划执行中的问题，及时向site提出data issue","link":"/2021/10/18/missing-visit/"},{"title":"testplan","text":"","link":"/2021/10/19/testplan/"},{"title":"人类群星闪耀时","text":"","link":"/2021/10/20/The-World-Minute-of-Waterloo/"},{"title":"畸恋、影视作品及谷崎润一郎","text":"","link":"/2021/10/20/relationship-pattern/"},{"title":"宏伟世纪与土耳其继承法","text":"","link":"/2021/10/20/magnificent-century/"},{"title":"生吃与钛","text":"","link":"/2021/10/20/titane/"}],"tags":[{"name":"Tech","slug":"Tech","link":"/tags/Tech/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"文化","slug":"文化","link":"/tags/%E6%96%87%E5%8C%96/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"R","slug":"R","link":"/tags/R/"},{"name":"历史","slug":"历史","link":"/tags/%E5%8E%86%E5%8F%B2/"},{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"DL","slug":"DL","link":"/tags/DL/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"打工","slug":"打工","link":"/tags/%E6%89%93%E5%B7%A5/"}],"categories":[]}